<!DOCTYPE html>
<html lang="en">
<head>
    <title>Ethereum Light</title>
    <style>
        #beaconApiBase, #trustedBlockRoot {
            width: 500px;
        }
        pre {
            display: inline;
        }
    </style>
</head>
<body>
    <h1>Checkpoint block lookup</h1>
    Current slot: <b><span id="wallSlot"></span></b><br />
    <br />
    Beacon-API base:<br /><input id="beaconApiBase" value="https://beacon-api.eth-light.xyz" /><br />
    <br />
    Checkpoint block root:<br /><input id="trustedBlockRoot" value="0x6796a6abceb2510235f3736b0f371ebe38eaef254917b5b26cc8cebe0937cb7f" /><input type="button" id="initButton" value="Init" disabled /><br />
    <br />

    <h1>Checkpoint header</h1>
    <ul>
        <li>
            <pre>finalized_header</pre>
            <ul>
                <li>
                    <pre>beacon</pre>: <b><pre id="finalizedBeaconRoot"></pre></b>
                    <ul>
                        <li><pre>slot</pre>: <b><pre id="finalizedBeaconSlot"></pre></b></li>
                        <li><pre>proposer_index</pre>: <b><pre id="finalizedBeaconProposerIndex"></pre></b></li>
                        <li><pre>parent_root</pre>: <b><pre id="finalizedBeaconParentRoot"></pre></b></li>
                        <li><pre>state_root</pre>: <b><pre id="finalizedBeaconStateRoot"></pre></b></li>
                        <li><pre>body_root</pre>: <b><pre id="finalizedBeaconBodyRoot"></pre></b></li>
                    </ul>
                </li>
            </ul>
        </li>
    </ul>

    <h1>Light client</h1>
    Next sync task: <b><span id="syncTask"></span></b><br />

    <h1>Secure random number demo</h1>
    <input id="rngOutput" readonly /><input type="button" id="rngButton" value="Rand" />

    <script>
        const networkMetadataPath = 'https://raw.githubusercontent.com/eth-clients/eth2-networks/master/shared/mainnet';

        async function loadCfg() {
            const response = await fetch(networkMetadataPath + '/config.yaml');
            assert(response.ok);
            const data = await response.text();

            const fileContent = Module.stringToNewUTF8(data);
            const cfg = Module._ETHRuntimeConfigCreateFromYaml(fileContent);
            assert(cfg);
            Module._free(fileContent);

            return cfg;
        }

        async function loadGenesis(cfg) {
            const consensusFork = Module._ETHRuntimeConfigGetConsensusForkAtEpoch(cfg, /* epoch: */ 0);
            const response = await fetch(networkMetadataPath + '/genesis.ssz');
            assert(response.ok);
            const data = await response.arrayBuffer();
            const sszBytes = new Uint8Array(data)

            const sszBytesPtr = Module._malloc(sszBytes.length);
            Module.HEAPU8.set(sszBytes, sszBytesPtr);
            const state = Module._ETHBeaconStateCreateFromSsz(cfg, consensusFork, sszBytesPtr, sszBytes.length);
            assert(state);
            Module._free(sszBytesPtr);

            return state;
        }

        function trackWallTime(beaconClock) {
            function onTick() {
                const slot = Module._ETHBeaconClockGetSlot(beaconClock);
                document.getElementById('wallSlot').innerText = slot;
                setTimeout(onTick, /* timeout: */ 100);
            }
            setTimeout(onTick, /* timeout: */ 100);
        }

        var Module = {};

        function visualizeStore(store) {
            function toHexString(bytes, numBytes) {
                let hexString = '0x';
                for (let i = 0; i < numBytes; i++) {
                    let hexByte = Module.HEAPU8[bytes + i].toString(16);
                    if (hexByte.length === 1) hexByte = '0' + hexByte;
                    hexString += hexByte;
                }
                return hexString;
            }

            const finalizedHeader = Module._ETHLightClientStoreGetFinalizedHeader(store);
            const beacon = Module._ETHLightClientHeaderGetBeacon(finalizedHeader);
            const root = Module._malloc(32);
            Module._ETHBeaconBlockHeaderGetRoot(beacon, root);
            document.getElementById('finalizedBeaconRoot').innerText = toHexString(root, 32);
            Module._free(root);
            const slot = Module._ETHBeaconBlockHeaderGetSlot(beacon);
            document.getElementById('finalizedBeaconSlot').innerText = slot;
            const proposerIndex = Module._ETHBeaconBlockHeaderGetProposerIndex(beacon);
            document.getElementById('finalizedBeaconProposerIndex').innerText = proposerIndex;
            const parentRoot = Module._ETHBeaconBlockHeaderGetParentRoot(beacon);
            document.getElementById('finalizedBeaconParentRoot').innerText = toHexString(parentRoot, 32);
            const stateRoot = Module._ETHBeaconBlockHeaderGetStateRoot(beacon);
            document.getElementById('finalizedBeaconStateRoot').innerText = toHexString(stateRoot, 32);
            const bodyRoot = Module._ETHBeaconBlockHeaderGetBodyRoot(beacon);
            document.getElementById('finalizedBeaconBodyRoot').innerText = toHexString(bodyRoot, 32);
        }

        let beaconApiBase = undefined;
        let beaconClock = undefined;
        let store = undefined;
        let storeId = 0;
        let trackStoreTimeout = undefined;
        function trackStore(newStore) {
            store = newStore;
            storeId++;
            function runOnTick(tickStoreId) {
                (async function () {
                    trackStoreTimeout = undefined;
                    visualizeStore(store);

                    const startPeriodPtr = Module._malloc(4);
                    const countPtr = Module._malloc(4);
                    const syncKind = Module._ETHLightClientStoreGetNextSyncTask(
                        store, beaconClock, startPeriodPtr, countPtr);
                    const startPeriod = Module.HEAPU32[startPeriodPtr >>> 2];
                    const count = Module.HEAPU32[countPtr >>> 2];
                    Module._free(startPeriodPtr);
                    Module._free(countPtr);

                    if (syncKind == Module.HEAPU8[Module._kETHLCSyncKind_UpdatesByRange]) {
                        document.getElementById('syncTask').innerText = 'UpdatesByRange(' + startPeriod + ", " + count + ')';
                        const response = await fetch(beaconApiBase +
                            '/eth/v1/beacon/light_client/updates?start_period=' + startPeriod + '&count=' + count, {
                                headers: {
                                    'Accept': 'application/octet-stream'
                                }
                            });
                        if (storeId != tickStoreId) return;
                    } else if (syncKind == Module.HEAPU8[Module._kETHLCSyncKind_FinalityUpdate]) {
                        document.getElementById('syncTask').innerText = 'FinalityUpdate';
                        const response = await fetch(beaconApiBase +
                            '/eth/v1/beacon/light_client/finality_update', {
                                headers: {
                                    'Accept': 'application/octet-stream'
                                }
                            });
                        if (storeId != tickStoreId) return;
                    } else {
                        assert(syncKind == Module.HEAPU8[Module._kETHLCSyncKind_OptimisticUpdate]);
                        document.getElementById('syncTask').innerText = 'OptimisticUpdate';
                        const response = await fetch(beaconApiBase +
                            '/eth/v1/beacon/light_client/optimistic_update', {
                                headers: {
                                    'Accept': 'application/octet-stream'
                                }
                            });
                        if (storeId != tickStoreId) return;
                    }
                })();
            }
            trackStoreTimeout = setTimeout(runOnTick(storeId), /* timeout: */ 0);
        }
        function clearStore() {
            if (trackStoreTimeout !== undefined) {
                clearTimeout(trackStoreTimeout);
                trackStoreTimeout = undefined;
            }
            if (store !== undefined) {
                Module._ETHLightClientStoreDestroy(store);
                store = undefined;
            }
        }

        Module.onRuntimeInitialized = async function() {
            const rng = Module._ETHRandomNumberCreate();
            const cfg = await loadCfg();
            const genesisState = await loadGenesis(cfg);
            beaconClock = Module._ETHBeaconClockCreateFromState(genesisState);
            Module._ETHBeaconStateDestroy(genesisState);
            trackWallTime(beaconClock);

            document.getElementById('rngButton').addEventListener('click', function() {
                document.getElementById('rngOutput').value = Module._ETHRandomNumberGet(rng);
            })

            document.getElementById('initButton').addEventListener('click', async function() {
                const trustedBlockRootString = document.getElementById('trustedBlockRoot').value;
                if (!/^0x[0-9a-fA-F]{64}$/.test(trustedBlockRootString)) {
                    return;
                }
                document.getElementById('initButton').disabled = true;
                clearStore();

                beaconApiBase = document.getElementById('beaconApiBase').value;
                const response = await fetch(beaconApiBase +
                    '/eth/v1/beacon/light_client/bootstrap/' + trustedBlockRootString, {
                        headers: {
                            'Accept': 'application/octet-stream'
                        }
                    });
                if (response.ok) {
                    const data = await response.arrayBuffer();
                    const bootstrapSszBytes = new Uint8Array(data);

                    const trustedBlockRootBytes = new Uint8Array(32);
                    for (let i = 0; i < trustedBlockRootBytes.length; i++) {
                        trustedBlockRootBytes[i] = parseInt(trustedBlockRootString.substr(i * 2 + 2, 2), 16);
                    }

                    const trustedBlockRootBytesPtr = Module._malloc(trustedBlockRootBytes.length);
                    Module.HEAPU8.set(trustedBlockRootBytes, trustedBlockRootBytesPtr);
                    const ethConsensusVersion = Module.stringToNewUTF8(response.headers.get('Eth-Consensus-Version'));
                    const bootstrapSszBytesPtr = Module._malloc(bootstrapSszBytes.length);
                    Module.HEAPU8.set(bootstrapSszBytes, bootstrapSszBytesPtr);
                    const newStore = Module._ETHLightClientStoreCreateFromBootstrap(
                        cfg, trustedBlockRootBytesPtr,
                        ethConsensusVersion, bootstrapSszBytesPtr, bootstrapSszBytes.length);
                    assert(newStore);
                    Module._free(bootstrapSszBytesPtr);
                    Module._free(ethConsensusVersion);
                    Module._free(trustedBlockRootBytesPtr);

                    trackStore(newStore);
                }
                document.getElementById('initButton').disabled = false;
            });
            document.getElementById('initButton').disabled = false;
        };
    </script>
    <script async src="light_client_wasm.js"></script>
</body>
</html>
