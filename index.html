<!DOCTYPE html>
<html lang="en">
<head>
    <title>Ethereum Light</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" crossorigin="anonymous"/>
    <style>
        @font-face {
            font-family: 'm_1mmedium';
            src: url('mplus-1m-medium-webfont.woff') format('woff');
            font-weight: normal;
            font-style: normal;
        }

        @font-face {
            font-family: 'm_1mlight';
            src: url('mplus-1m-light-webfont.woff') format('woff');
            font-weight: normal;
            font-style: normal;
        }

        a {
            text-decoration: none;
        }

        #mdMaster {
            width: 270px;
            height: 100vh;
            position: fixed;
            left: 0;
            top: 0;
            background-color: #f9f9f9;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
            padding: 10px;
            overflow-y: scroll;
        }

        #mdDetail {
            margin-left: 300px;
            padding: 10px;
        }

        .headerMaster {
            margin: 10px 0px 5px;
            padding: 10px 5px 10px;
            background-color: #e9e9e9;
            border-radius: 5px;
        }

        .headerMasterBeaconRoot {
            font-family: 'm_1mmedium', monospace;
            font-size: 1em;
            text-align: center;
        }

        .headerMasterInfo {
            padding: 0px 3px 0px 3px;
            font-family: 'm_1mlight', monospace;
            font-size: 0.7em;
            border: 1px green;
        }

        .headerMasterInfo table {
            white-space: nowrap;
            border-collapse: collapse;
        }

        .headerMasterInfo td {
            width: 60px;
            padding-top: 5px;
        }

        .fas {
            width: 12px;
            text-align: center;
        }

        #beaconApiBase, #executionApiBase, #trustedBlockRoot {
            width: 230px;
            font-family: 'm_1mlight', monospace;
        }
    </style>
</head>
<body>
    <div id="mdMaster">
        <div id="masterTop" class="headerMaster">
            <div class="headerMasterInfo">
                <table style="width: 100%">
                    <tr>
                        <td><input type="button" id="settingsButton" value="Settings" /></td>
                    </tr>
                </table>
            </div>
        </div>
        <div id="settings" class="headerMaster" hidden="hidden">
            <div class="headerMasterInfo">
                <table style="width: 100%">
                    <tr>
                        <td><span class="fas fa-satellite-dish"></span> <input id="beaconApiBase" value="https://beacon-api.eth-light.xyz" /></td>
                    </tr>
                    <tr>
                        <td><span class="fas fa-cogs"></span> <input id="executionApiBase" value="https://mainnet.infura.io/v3/d0366f5631e045198d9bb487228a6ec7" /></td>
                    </tr>
                    <tr>
                        <td><span class="fas fa-shield-alt"></span> <input id="trustedBlockRoot" value="0x15cf56ebf887ede9cf3fc10a26ec83828628932c100e42c98c84f83da710c863" /></td>
                    </tr>
                    <tr>
                        <td><input type="button" id="initButton" value="Save" disabled /></td>
                    </tr>
                </table>
            </div>
        </div>
        <div id="headerList" hidden="hidden"></div>
        <div id="selectedHeaderDetail" hidden="hidden">
            <div id="selectedHeader" class="headerMaster">
                <div id="selectedBeaconRoot" class="headerMasterBeaconRoot"></div>
                <div class="headerMasterInfo">
                    <table style="width: 100%">
                        <tr>
                            <td><span class="fas fa-satellite-dish"></span> <span id="selectedBeaconSlot"></span></td>
                            <td><span class="fas fa-cubes"></span> <span id="selectedExecutionBlockNumber"></span></td>
                            <td colspan="2" style="text-align: right;"><span class="fas fa-clock"></span> <span id="selectedExecutionTimestamp"></span></td>
                        </tr>
                        <tr>
                            <td><span class="fas fa-user-check"></span> <span id="selectedBeaconProposerIndex"></span></td>
                            <td colspan="2" class="a"><span class="fas fa-tachometer-alt"></span> <span id="selectedExecutionGasUsedPercentage"></span> <span id="selectedExecutionGasUsed"></span>/<span id="selectedExecutionGasLimit"></span></td>
                            <td style="text-align: right;"><span class="fas fa-fire-flame-curved"></span> <span id="selectedExecutionBaseFeePerGas"></span></td>
                        </tr>
                        <tr>
                            <td colspan="4"><span class="fas fa-hand-holding-usd"></span> <span id="selectedExecutionFeeRecipient" style="display: inline-block; transform: scaleX(1.015); transform-origin: left;"></span></td>
                        </tr>
                        <tr>
                            <td colspan="4"><input type="button" id="backButton" value="Back" /></td>
                        </tr>
                    </table>
                </div>
            </div>
            <div id="selectedTransactionList"></div>
        </div>
    </div>
    <div id="mdDetail">
    </div>

    <script>
        const networkMetadataPath = 'https://raw.githubusercontent.com/eth-clients/eth2-networks/master/shared/mainnet';

        async function loadCfg() {
            const response = await fetch(networkMetadataPath + '/config.yaml');
            assert(response.ok);
            const data = await response.text();

            const fileContent = Module.stringToNewUTF8(data);
            const cfg = Module._ETHConsensusConfigCreateFromYaml(fileContent);
            assert(cfg);
            Module._free(fileContent);

            return cfg;
        }

        async function loadGenesis(cfg) {
            const consensusFork = Module._ETHConsensusConfigGetConsensusVersionAtEpoch(cfg, /* epoch: */ 0);
            const response = await fetch(networkMetadataPath + '/genesis.ssz');
            assert(response.ok);
            const data = await response.arrayBuffer();
            const sszBytes = new Uint8Array(data)

            const sszBytesPtr = Module._malloc(sszBytes.length);
            Module.HEAPU8.set(sszBytes, sszBytesPtr);
            const state = Module._ETHBeaconStateCreateFromSsz(cfg, consensusFork, sszBytesPtr, sszBytes.length);
            assert(state);
            Module._free(sszBytesPtr);

            return state;
        }

        var Module = {};

        let beaconApiBase = undefined;
        let executionApiBase = undefined;

        const zeroHash = '0x0000000000000000000000000000000000000000000000000000000000000000';

        function toHexString(bytes, numBytes) {
            const array = Array.from(Module.HEAPU8.subarray(bytes, bytes + numBytes))
            return '0x' + array.reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');
        }

        function toDecString(bytes, numBytes) {
            const array = Array.from(Module.HEAPU8.subarray(bytes, bytes + numBytes)).reverse();
            const num = BigInt('0x' + array.reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), ''));
            return num.toString();
        }

        function toHumanReadableByteCountString(numBytes) {
            if (numBytes >= 1e12) {
                return (numBytes / 1e12).toFixed(1) + ' TB';
            }
            if (numBytes >= 1e11) {
                return (numBytes / 1e9).toFixed(0) + ' GB';
            }
            if (numBytes >= 1e9) {
                return (numBytes / 1e9).toFixed(1) + ' GB';
            }
            if (numBytes >= 1e8) {
                return (numBytes / 1e6).toFixed(0) + ' MB';
            }
            if (numBytes >= 1e6) {
                return (numBytes / 1e6).toFixed(1) + ' MB';
            }
            if (numBytes >= 1e5) {
                return (numBytes / 1e3).toFixed(0) + ' KB';
            }
            if (numBytes >= 1e3) {
                return (numBytes / 1e3).toFixed(1) + ' KB';
            }
            return numBytes + ' bytes'
        }

        function toHumanReadableNumberString(number) {
            if (number >= 1e12) {
                return (number / 1e12).toFixed(1) + 'T';
            }
            if (number >= 1e11) {
                return (number / 1e9).toFixed(0) + 'T';
            }
            if (number >= 1e9) {
                return (number / 1e9).toFixed(1) + 'B';
            }
            if (number >= 1e8) {
                return (number / 1e6).toFixed(0) + 'M';
            }
            if (number >= 1e6) {
                return (number / 1e6).toFixed(1) + 'M';
            }
            if (number >= 1e5) {
                return (number / 1e3).toFixed(0) + 'K';
            }
            if (number >= 1e3) {
                return (number / 1e3).toFixed(1) + 'K';
            }
            return number.toString();
        }

        function toDateString(timestamp) {
            const date = new Date(timestamp * 1000);
            const year = date.getFullYear();
            const month = ('0' + (date.getMonth() + 1)).slice(-2);
            const day = ('0' + date.getDate()).slice(-2);
            const hours = ('0' + date.getHours()).slice(-2);
            const minutes = ('0' + date.getMinutes()).slice(-2);
            const seconds = ('0' + date.getSeconds()).slice(-2);
            return `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
        }

        function toGweiString(bytes, numBytes) {
            const array = Array.from(Module.HEAPU8.subarray(bytes, bytes + numBytes)).reverse();
            const wei = BigInt('0x' + array.reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), ''));
            const weiString = wei.toString().padStart(9, '0');
            const beforeDecimal = weiString.substring(0, weiString.length - 9);
            if (beforeDecimal === '') {
                return '0';
            }
            return beforeDecimal;
        }

        function toEthString(bytes, numBytes) {
            const array = Array.from(Module.HEAPU8.subarray(bytes, bytes + numBytes)).reverse();
            const wei = BigInt('0x' + array.reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), ''));
            const weiString = wei.toString().padStart(18, '0');
            const beforeDecimal = weiString.substring(0, weiString.length - 18);
            const afterDecimal = weiString.substring(weiString.length - 18).replace(/0+$/, '');
            if (beforeDecimal === '') {
                if (afterDecimal === '') {
                    return '0';
                }
                return '0.' + afterDecimal;
            }
            if (afterDecimal === '') {
                return beforeDecimal;
            }
            return beforeDecimal + '.' + afterDecimal;
        }

        function getBeaconRoot(header) {
            const beaconRoot = Module._ETHLightClientHeaderCopyBeaconRoot(header, cfg);
            const beaconRootString = toHexString(beaconRoot, 32);
            Module._ETHRootDestroy(beaconRoot);
            return beaconRootString;
        }

        function getBeaconSlot(header) {
            const beacon = Module._ETHLightClientHeaderGetBeacon(header);
            return Module._ETHBeaconBlockHeaderGetSlot(beacon);
        }

        function initHeadersCache() {
            let headers = [];
            let byRoot = {};
            let executionBlocks = {};

            return {
                'add': function (header, cfg) {
                    const beaconRoot = getBeaconRoot(header);
                    if (byRoot[beaconRoot]) {
                        return;
                    }

                    const beaconSlot = getBeaconSlot(header);
                    const i = headers.findIndex(x => (beaconSlot > getBeaconSlot(x)) ||
                        (beaconSlot == getBeaconSlot && beaconRoot < getBeaconRoot(x)));
                    const copy = Module._ETHLightClientHeaderCreateCopy(header)
                    headers.splice(i >= 0 ? i : headers.length, 0, copy);
                    byRoot[beaconRoot] = copy;

                    if (headers.length > 128) {
                        const removedHeader = headers.pop();
                        const removedBeaconRoot = getBeaconRoot(removedHeader);

                        const removedExecutionBlock = executionBlocks[removedBeaconRoot];
                        if (removedExecutionBlock) {
                            const [removedExecutionBlockHeader, removedTransactions] = removedExecutionBlock;
                            delete executionBlocks[removedBeaconRoot];
                            Module._ETHTransactionsDestroy(removedTransactions);
                            Module._ETHExecutionBlockHeaderDestroy(removedExecutionBlockHeader);
                        }

                        delete byRoot[removedBeaconRoot];
                        Module._ETHLightClientHeaderDestroy(removedHeader);
                    }
                },

                'getAll': function () {
                    return headers;
                },

                'get': function (beaconRoot) {
                    return byRoot[beaconRoot];
                },

                'setExecutionBlock': function (beaconRoot, executionBlock) {
                    executionBlocks[beaconRoot] = executionBlock;
                },

                'getExecutionBlock': function (beaconRoot) {
                    return executionBlocks[beaconRoot];
                }
            };
        }

        let headers = initHeadersCache();

        async function fetchExecutionBlock(header) {
            const executionHash = Module._ETHLightClientHeaderCopyExecutionHash(header, cfg);
            try {
                const executionHashString = toHexString(executionHash, 32);
                if (executionHashString == zeroHash) return;
                const beaconRoot = getBeaconRoot(header);
                let executionBlock = headers.getExecutionBlock(beaconRoot);
                if (executionBlock) {
                    return executionBlock;
                }

                let data;
                try {
                    const executionBlockResponse = await fetch(executionApiBase, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            jsonrpc: '2.0',
                            id: 1,
                            method: 'eth_getBlockByHash',
                            params: [executionHashString, /* fullTransactions: */ true]
                        })
                    });
                    if (!executionBlockResponse.ok) return;
                    const executionBlockJson = await executionBlockResponse.json();
                    if (!executionBlockJson.result) return;
                    data = executionBlockJson.result;
                } catch {
                    return;
                }
                if (!headers.get(beaconRoot)) return;

                const fullTransactions = JSON.stringify(data.transactions);
                for (txIndex in data.transactions) {
                    data.transactions[txIndex] = data.transactions[txIndex].hash;
                }
                const blockHeaderJson = Module.stringToNewUTF8(JSON.stringify(data));
                const executionBlockHeader = Module._ETHExecutionBlockHeaderCreateFromJson(executionHash, blockHeaderJson);
                Module._free(blockHeaderJson);
                if (!executionBlockHeader) return;

                const executionTransactionsRoot = Module._ETHExecutionBlockHeaderGetTransactionsRoot(executionBlockHeader);
                const transactionsJson = Module.stringToNewUTF8(fullTransactions);
                const transactions = Module._ETHTransactionsCreateFromJson(executionTransactionsRoot, transactionsJson);
                Module._free(transactionsJson);
                if (!transactions) {
                    Module._ETHExecutionBlockHeaderDestroy(executionBlockHeader);
                    return;
                }

                executionBlock = [executionBlockHeader, transactions];
                headers.setExecutionBlock(beaconRoot, executionBlock);
                return executionBlock;
            } finally {
                Module._ETHRootDestroy(executionHash);
            }
        }

        function visualizeHeader(prefix, header) {
            const beaconRoot = getBeaconRoot(header);
            if (document.getElementById(prefix + 'BeaconRoot').dataset.beaconRoot === beaconRoot) return;
            document.getElementById(prefix + 'BeaconRoot').dataset.beaconRoot = beaconRoot;

            document.getElementById(prefix + 'BeaconRoot').innerHTML =
                '<a href="https://beaconcha.in/slot/' + beaconRoot + '" target="_blank">' +
                beaconRoot.substring(2, 34) + '<br />' + beaconRoot.substring(34) + '</a>';
            const beacon = Module._ETHLightClientHeaderGetBeacon(header);
            const beaconSlot = Module._ETHBeaconBlockHeaderGetSlot(beacon);
            document.getElementById(prefix + 'BeaconSlot').innerHTML =
                '<a href="https://beaconcha.in/slot/' + beaconSlot + '" target="_blank">' +
                beaconSlot + '</a>';
            const beaconProposerIndex = Module._ETHBeaconBlockHeaderGetProposerIndex(beacon);
            document.getElementById(prefix + 'BeaconProposerIndex').innerHTML =
                '<a href="https://beaconcha.in/validator/' + beaconProposerIndex + '" target="_blank">' +
                beaconProposerIndex + '</a>';
            const beaconParentRoot = Module._ETHBeaconBlockHeaderGetParentRoot(beacon);
            const beaconStateRoot = Module._ETHBeaconBlockHeaderGetStateRoot(beacon);
            const beaconBodyRoot = Module._ETHBeaconBlockHeaderGetBodyRoot(beacon);

            const executionHash = Module._ETHLightClientHeaderCopyExecutionHash(header, cfg);
            const executionHashString = toHexString(executionHash, 32);
            Module._ETHRootDestroy(executionHash);
            const execution = Module._ETHLightClientHeaderGetExecution(header);
            const executionParentHash = Module._ETHExecutionPayloadHeaderGetParentHash(execution);
            const executionFeeRecipient = Module._ETHExecutionPayloadHeaderGetFeeRecipient(execution);
            document.getElementById(prefix + 'ExecutionFeeRecipient').innerHTML =
                '<a href="https://etherscan.io/address/' + toHexString(executionFeeRecipient, 20) + '#mine" target="_blank">' +
                toHexString(executionFeeRecipient, 20) + '</a>';
            const executionStateRoot = Module._ETHExecutionPayloadHeaderGetStateRoot(execution);
            const executionReceiptsRoot = Module._ETHExecutionPayloadHeaderGetReceiptsRoot(execution);
            const executionLogsBloom = Module._ETHExecutionPayloadHeaderGetLogsBloom(execution);
            const executionPrevRandao = Module._ETHExecutionPayloadHeaderGetPrevRandao(execution);
            const executionBlockNumber = Module._ETHExecutionPayloadHeaderGetBlockNumber(execution);
            document.getElementById(prefix + 'ExecutionBlockNumber').innerHTML =
                '<a href="https://etherscan.io/block/' + executionHashString + '" target="_blank">' +
                executionBlockNumber + '</a>';
            const executionGasLimit = Module._ETHExecutionPayloadHeaderGetGasLimit(execution);
            document.getElementById(prefix + 'ExecutionGasLimit').innerText = toHumanReadableNumberString(executionGasLimit);
            const executionGasUsed = Module._ETHExecutionPayloadHeaderGetGasUsed(execution);
            document.getElementById(prefix + 'ExecutionGasUsed').innerText = toHumanReadableNumberString(executionGasUsed);
            document.getElementById(prefix + 'ExecutionGasUsedPercentage').innerText = (executionGasUsed * 100 / executionGasLimit).toFixed(2) + '%';
            const executionTimestamp = Module._ETHExecutionPayloadHeaderGetTimestamp(execution);
            document.getElementById(prefix + 'ExecutionTimestamp').innerText = toDateString(executionTimestamp);
            const executionExtraDataBytes = Module._ETHExecutionPayloadHeaderGetExtraDataBytes(execution);
            const numExecutionExtraDataBytes = Module._ETHExecutionPayloadHeaderGetNumExtraDataBytes(execution);
            const executionBaseFeePerGas = Module._ETHExecutionPayloadHeaderGetBaseFeePerGas(execution);
            document.getElementById(prefix + 'ExecutionBaseFeePerGas').innerText = toGweiString(executionBaseFeePerGas, 32) + ' Gwei';
            const executionBlobGasUsed = Module._ETHExecutionPayloadHeaderGetBlobGasUsed(execution);
            const executionExcessBlobGas = Module._ETHExecutionPayloadHeaderGetExcessBlobGas(execution);

            function fillExecutionInfo() {
                if (executionHash == zeroHash) {
                    document.getElementById(prefix + 'TransactionList').innerHTML = '';
                } else {
                    document.getElementById(prefix + 'TransactionList').innerHTML = '';

                    const executionBlockFut = fetchExecutionBlock(header);
                    executionBlockFut.then((executionBlock) => {
                        if (document.getElementById(prefix + 'BeaconRoot').dataset.beaconRoot !== beaconRoot) return;
                        if (!executionBlock) {
                            document.getElementById(prefix + 'TransactionList').innerHTML =
                                '<div class="headerMaster">' +
                                '   <div class="headerMasterBeaconRoot">Failed to validate transactions</div>' +
                                '   <div class="headerMasterInfo">' +
                                '       <table style="width: 100%">' +
                                '           <tr>' +
                                '               <td><input type="button" id="' +
                                prefix + 'ExecutionReloadButton' +
                                '" value="Retry" /></td>' +
                                '           </tr>' +
                                '       </table>' +
                                '   </div>' +
                                '</div>';
                            document.getElementById(prefix + 'ExecutionReloadButton').onclick = fillExecutionInfo;
                            return;
                        }

                        const [executionBlockHeader, transactions] = executionBlock;
                        const executionTransactionsRoot = Module._ETHExecutionBlockHeaderGetTransactionsRoot(executionBlockHeader);
                        const executionWithdrawalsRoot = Module._ETHExecutionBlockHeaderGetWithdrawalsRoot(executionBlockHeader);

                        const numTransactions = Module._ETHTransactionsGetCount(transactions);
                        document.getElementById(prefix + 'TransactionList').innerHTML = '';
                        const numTransactionInputBytesPtr = Module._malloc(4);
                        assert(numTransactionInputBytesPtr);
                        const numTransactionBytesPtr = Module._malloc(4);
                        assert(numTransactionBytesPtr);
                        for (let transactionIndex = 0; transactionIndex < numTransactions; transactionIndex++) {
                            const transaction = Module._ETHTransactionsGet(transactions, transactionIndex);

                            const transactionHash = Module._ETHTransactionGetHash(transaction);
                            const transactionHashString = toHexString(transactionHash, 32);
                            const transactionFrom = Module._ETHTransactionGetFrom(transaction);
                            const transactionNonce = Module._ETHTransactionGetNonce(transaction);
                            const transactionMaxPriorityFeePerGas = Module._ETHTransactionGetMaxPriorityFeePerGas(transaction);
                            const transactionMaxFeePerGas = Module._ETHTransactionGetMaxFeePerGas(transaction);
                            const transactionGas = Module._ETHTransactionGetGas(transaction);
                            const transactionIsCreatingContract = Module._ETHTransactionIsCreatingContract(transaction);
                            const transactionTo = Module._ETHTransactionGetTo(transaction);
                            const transactionValue = Module._ETHTransactionGetValue(transaction);
                            const transactionInputBytes = Module._ETHTransactionGetInputBytes(transaction, numTransactionInputBytesPtr);
                            const numTransactionInputBytes = Module.HEAPU32[numTransactionInputBytesPtr >>> 2];
                            const transactionBytes = Module._ETHTransactionGetBytes(transaction, numTransactionBytesPtr);
                            const transactionBytesString = toHexString(transactionBytes, Module.HEAPU32[numTransactionBytesPtr >>> 2]);

                            const transactionDiv = document.createElement('div');
                            transactionDiv.id = `txMaster_${transactionHashString}`;
                            transactionDiv.dataset.transactionHash = transactionHashString;
                            transactionDiv.className = 'headerMaster';
                            transactionDiv.innerHTML =
                                '<div class="headerMasterBeaconRoot">' +
                                '<a href="https://etherscan.io/tx/' + transactionHashString + '" target="_blank">' +
                                transactionHashString.substring(2, 34) + '<br />' + transactionHashString.substring(34) + '</a>' +
                                '</div>' +
                                '<div class="headerMasterInfo">' +
                                '    <table style="width: 100%">' +
                                '        <tr>' +
                                '            <td><span class="fas fa-hashtag"></span> <span>' +
                                toDecString(transactionNonce, 8) +
                                '</span></td>' +
                                '            <td><span class="fas fa-tachometer-alt"></span> <span>' +
                                toHumanReadableNumberString(Number(toDecString(transactionGas, 8))) +
                                '</span></td>' +
                                '            <td><span class="fas fa-money-bill-1"></span> <span>' +
                                toGweiString(transactionMaxPriorityFeePerGas, 8) + ' Gwei' +
                                '</span></td>' +
                                '            <td style="text-align: right;"><span class="fas fa-gas-pump"></span> <span>' +
                                toGweiString(transactionMaxFeePerGas, 8) + ' Gwei' +
                                '</span></td>' +
                                '        </tr>' +
                                '        <tr>' +
                                '            <td colspan="4"><span class="fas fa-right-from-bracket"></span> <span style="display: inline-block; transform: scaleX(1.015); transform-origin: left;">' +
                                '<a href="https://etherscan.io/address/' + toHexString(transactionFrom, 20) + '" target="_blank">' +
                                toHexString(transactionFrom, 20) + '</a>' +
                                '</span></td>' +
                                '        </tr>' +
                                '        <tr>' +
                                '            <td colspan="3"><span class="fas fa-brands fa-ethereum"></span> <span>' +
                                toEthString(transactionValue, 32) + ' ETH' +
                                '</span></td>' +
                                '            <td colspan="1" style="text-align: right;"><span class="fas fa-file-arrow-up"></span> <span>' +
                                toHumanReadableByteCountString(numTransactionInputBytes) +
                                '</span></td>' +
                                '        </tr>' +
                                '        <tr>' +
                                '            <td colspan="4"><span class="fas ' +
                                (transactionIsCreatingContract ? 'fa-star-of-life' : 'fa-right-to-bracket') +
                                '"></span> <span style="display: inline-block; transform: scaleX(1.015); transform-origin: left;">' +
                                '<a href="https://etherscan.io/address/' + toHexString(transactionTo, 20) + '" target="_blank">' +
                                toHexString(transactionTo, 20) + '</a>' +
                                '</span></td>' +
                                '        </tr>' +
                                '    </table>' +
                                '</div>';

                            document.getElementById(prefix + 'TransactionList').appendChild(transactionDiv);
                        }
                        Module._free(numTransactionBytesPtr);
                        Module._free(numTransactionInputBytesPtr);
                    });
                }
            }
            fillExecutionInfo();
        }

        let selectedHeader = undefined;

        document.getElementById('settingsButton').onclick = function () {
            document.getElementById('masterTop').hidden = true;
            document.getElementById('headerList').hidden = true;
            document.getElementById('selectedHeaderDetail').hidden = true;
            document.getElementById('settings').hidden = false;
        }

        document.getElementById('backButton').onclick = function () {
            selectedHeader = undefined;
            document.getElementById('selectedHeaderDetail').hidden = true;
            document.getElementById('headerList').hidden = false;
        };

        function cacheHeaders(store, cfg) {
            const finalizedRoot = getBeaconRoot(Module._ETHLightClientStoreGetFinalizedHeader(store));
            document.getElementById('trustedBlockRoot').value = finalizedRoot;
            localStorage.setItem('trustedBlockRoot', finalizedRoot);

            headers.add(Module._ETHLightClientStoreGetOptimisticHeader(store), cfg);
            headers.add(Module._ETHLightClientStoreGetFinalizedHeader(store), cfg);

            const newHeaders = headers.getAll();
            const oldHeaderDivs = Array.from(headerList.children);

            let i = 0;
            let j = 0;

            while (i < newHeaders.length || j < oldHeaderDivs.length) {
                const newHeader = newHeaders[i];
                let beaconRoot = undefined;
                let beaconSlot = undefined;
                if (newHeader) {
                    beaconRoot = getBeaconRoot(newHeader);
                    beaconSlot = getBeaconSlot(newHeader);
                }

                const oldHeaderDiv = oldHeaderDivs[j];
                if (newHeader && oldHeaderDiv && beaconRoot == oldHeaderDiv.dataset.beaconRoot) {
                    i++;
                    j++;
                } else if (newHeader && (!oldHeaderDiv ||
                    beaconSlot > oldHeaderDiv.dataset.beaconSlot ||
                    (beaconSlot == oldHeaderDiv.dataset.beaconSlot &&
                    beaconRoot < oldHeaderDiv.dataset.beaconRoot)))
                {
                    const beacon = Module._ETHLightClientHeaderGetBeacon(newHeader);
                    const beaconProposerIndex = Module._ETHBeaconBlockHeaderGetProposerIndex(beacon);
                    const executionHash = Module._ETHLightClientHeaderCopyExecutionHash(newHeader, cfg);
                    const executionHashString = toHexString(executionHash, 32);
                    Module._ETHRootDestroy(executionHash);
                    const execution = Module._ETHLightClientHeaderGetExecution(newHeader);
                    const executionFeeRecipient = Module._ETHExecutionPayloadHeaderGetFeeRecipient(execution);
                    const executionBlockNumber = Module._ETHExecutionPayloadHeaderGetBlockNumber(execution);
                    const executionGasLimit = Module._ETHExecutionPayloadHeaderGetGasLimit(execution);
                    const executionGasUsed = Module._ETHExecutionPayloadHeaderGetGasUsed(execution);
                    const executionTimestamp = Module._ETHExecutionPayloadHeaderGetTimestamp(execution);
                    const executionBaseFeePerGas = Module._ETHExecutionPayloadHeaderGetBaseFeePerGas(execution);

                    const detailsButtonId = `detailsButton_${beaconRoot}`;
                    let headerDiv = document.createElement('div');
                    headerDiv.id = `headerMaster_${beaconRoot}`;
                    headerDiv.dataset.beaconRoot = beaconRoot;
                    headerDiv.dataset.beaconSlot = beaconSlot;
                    headerDiv.className = 'headerMaster';
                    headerDiv.innerHTML =
                        '<div class="headerMasterBeaconRoot">' +
                        '<a href="https://beaconcha.in/slot/' + beaconRoot + '" target="_blank">' +
                        beaconRoot.substring(2, 34) + '<br />' + beaconRoot.substring(34) + '</a>' +
                        '</div>' +
                        '<div class="headerMasterInfo">' +
                        '    <table style="width: 100%">' +
                        '        <tr>' +
                        '            <td><span class="fas fa-satellite-dish"></span> <span>' +
                        '<a href="https://beaconcha.in/slot/' + beaconSlot + '" target="_blank">' +
                        beaconSlot + '</a>' +
                        '</span></td>' +
                        '            <td><span class="fas fa-cubes"></span> <span>' +
                        '<a href="https://etherscan.io/block/' + executionHashString + '" target="_blank">' +
                        executionBlockNumber + '</a>' +
                        '</span></td>' +
                        '            <td colspan="2" style="text-align: right;"><span class="fas fa-clock"></span> <span>' +
                        toDateString(executionTimestamp) +
                        '</span></td>' +
                        '        </tr>' +
                        '        <tr>' +
                        '            <td><span class="fas fa-user-check"></span> <span>' +
                        '<a href="https://beaconcha.in/validator/' + beaconProposerIndex + '" target="_blank">' +
                        beaconProposerIndex + '</a>' +
                        '</span></td>' +
                        '            <td colspan="2" class="a"><span class="fas fa-tachometer-alt"></span> <span>' +
                        (executionGasUsed * 100 / executionGasLimit).toFixed(2) + '%' +
                        '</span> <span>' +
                        toHumanReadableNumberString(executionGasUsed) +
                        '</span>/<span>' +
                        toHumanReadableNumberString(executionGasLimit) +
                        '</span></td>' +
                        '            <td style="text-align: right;"><span class="fas fa-fire-flame-curved"></span> <span>' +
                        toGweiString(executionBaseFeePerGas, 32) + ' Gwei' +
                        '</span></td>' +
                        '        </tr>' +
                        '        <tr>' +
                        '            <td colspan="4"><span class="fas fa-hand-holding-usd"></span> <span style="display: inline-block; transform: scaleX(1.015); transform-origin: left;">' +
                        '<a href="https://etherscan.io/address/' + toHexString(executionFeeRecipient, 20) + '#mine" target="_blank">' +
                        toHexString(executionFeeRecipient, 20) + '</a>' +
                        '</span></td>' +
                        '        </tr>' +
                        '        <tr>' +
                        '            <td colspan="4"><input type="button" id="' +
                        detailsButtonId +
                        '" value="Details" /></td>' +
                        '        </tr>' +
                        '    </table>' +
                        '</div>';

                    headerList.insertBefore(headerDiv, oldHeaderDiv);
                    i++;

                    document.getElementById(detailsButtonId).onclick = function () {
                        const header = headers.get(beaconRoot);
                        if (header) {
                            selectedHeader = beaconRoot;
                            visualizeHeader('selected', header);
                            document.getElementById('headerList').hidden = true;
                            document.getElementById('selectedHeaderDetail').hidden = false;
                        }
                    };
                } else {
                    headerList.removeChild(oldHeaderDiv);
                    j++;
                }
            }
        }

        let rng = undefined;
        let cfg = undefined;
        let genesisValRoot = undefined;
        let forkDigests = undefined;
        let beaconClock = undefined;
        let store = undefined;
        let storeId = 0;
        let trackStoreTimeout = undefined;
        let trackStoreSource = undefined;
        let nextSyncTaskTime = undefined;
        function trackStore(newStore) {
            store = newStore;
            storeId++;

            function setupSource(tickStoreId) {
                trackStoreSource = new EventSource(beaconApiBase +
                    '/eth/v1/events?topics=light_client_finality_update&topics=light_client_optimistic_update');

                trackStoreSource.addEventListener('light_client_finality_update', function (event) {
                    if (storeId != tickStoreId) return;
                    const mediaType = Module.stringToNewUTF8("application/json");
                    const finUpdatesBytesPtr = Module.stringToNewUTF8(event.data);
                    const numFinUpdateBytes = Module.lengthBytesUTF8(event.data);
                    const res = Module._ETHLightClientStoreProcessFinalityUpdate(
                        store, cfg, forkDigests, genesisValRoot, beaconClock,
                        mediaType, /* consensusVersion: */ 0, finUpdatesBytesPtr, numFinUpdateBytes);
                    Module._free(finUpdatesBytesPtr);
                    Module._free(mediaType);
                    cacheHeaders(store, cfg);
                });

                trackStoreSource.addEventListener('light_client_optimistic_update', function (event) {
                    if (storeId != tickStoreId) return;
                    const mediaType = Module.stringToNewUTF8("application/json");
                    const optUpdateBytesPtr = Module.stringToNewUTF8(event.data);
                    const numOptUpdateBytes = Module.lengthBytesUTF8(event.data);
                    const res = Module._ETHLightClientStoreProcessOptimisticUpdate(
                        store, cfg, forkDigests, genesisValRoot, beaconClock,
                        mediaType, /* consensusVersion: */ 0, optUpdateBytesPtr, numOptUpdateBytes);
                    Module._free(optUpdateBytesPtr);
                    Module._free(mediaType);
                    cacheHeaders(store, cfg);
                });
            }

            function runOnTick(tickStoreId, timeout) {
                cacheHeaders(store, cfg);
                async function onTick() {
                    if (storeId != tickStoreId) return;
                    if (nextSyncTaskTime !== undefined && Date.now() < nextSyncTaskTime) {
                        runOnTick(storeId, /* timeout: */ 100);
                        return;
                    }

                    trackStoreTimeout = undefined;
                    nextSyncTaskTime = undefined;

                    const startPeriodPtr = Module._malloc(4);
                    const countPtr = Module._malloc(4);
                    const syncKind = Module._ETHLightClientStoreGetNextSyncTask(
                        store, beaconClock, startPeriodPtr, countPtr);
                    const startPeriod = Module.HEAPU32[startPeriodPtr >>> 2];
                    let count = Module.HEAPU32[countPtr >>> 2];
                    Module._free(countPtr);
                    Module._free(startPeriodPtr);

                    let res = 1;
                    if (syncKind == Module.HEAPU8[Module._kETHLcSyncKind_UpdatesByRange]) {
                        const maxUpdatesByRange = 1;
                        if (count > maxUpdatesByRange) count = maxUpdatesByRange;
                        const response = await fetch(beaconApiBase +
                            '/eth/v1/beacon/light_client/updates?start_period=' + startPeriod + '&count=' + count, {
                                headers: {
                                    'Accept': 'application/octet-stream'
                                }
                            });
                        if (storeId != tickStoreId) return;
                        if (response.ok) {
                            const data = await response.arrayBuffer();
                            if (storeId != tickStoreId) return;
                            const updatesBytes = new Uint8Array(data);

                            const mediaType = Module.stringToNewUTF8(response.headers.get('Content-Type'));
                            const updatesBytesPtr = Module._malloc(updatesBytes.length);
                            Module.HEAPU8.set(updatesBytes, updatesBytesPtr);
                            res = Module._ETHLightClientStoreProcessUpdatesByRange(
                                store, cfg, forkDigests, genesisValRoot, beaconClock,
                                startPeriod, count, mediaType, updatesBytesPtr, updatesBytes.length);
                            Module._free(updatesBytesPtr);
                            Module._free(mediaType);
                        }
                    } else if (syncKind == Module.HEAPU8[Module._kETHLcSyncKind_FinalityUpdate]) {
                        const response = await fetch(beaconApiBase +
                            '/eth/v1/beacon/light_client/finality_update', {
                                headers: {
                                    'Accept': 'application/octet-stream'
                                }
                            });
                        if (storeId != tickStoreId) return;
                        if (response.ok) {
                            const data = await response.arrayBuffer();
                            if (storeId != tickStoreId) return;
                            const finUpdateBytes = new Uint8Array(data);

                            const mediaType = Module.stringToNewUTF8(response.headers.get('Content-Type'));
                            const consensusVersion = Module.stringToNewUTF8(response.headers.get('Eth-Consensus-Version'));
                            const finUpdatesBytesPtr = Module._malloc(finUpdateBytes.length);
                            Module.HEAPU8.set(finUpdateBytes, finUpdatesBytesPtr);
                            res = Module._ETHLightClientStoreProcessFinalityUpdate(
                                store, cfg, forkDigests, genesisValRoot, beaconClock,
                                mediaType, consensusVersion, finUpdatesBytesPtr, finUpdateBytes.length);
                            Module._free(finUpdatesBytesPtr);
                            Module._free(consensusVersion);
                            Module._free(mediaType);
                        }
                    } else {
                        assert(syncKind == Module.HEAPU8[Module._kETHLcSyncKind_OptimisticUpdate]);
                        const response = await fetch(beaconApiBase +
                            '/eth/v1/beacon/light_client/optimistic_update', {
                                headers: {
                                    'Accept': 'application/octet-stream'
                                }
                            });
                        if (storeId != tickStoreId) return;
                        if (response.ok) {
                            const data = await response.arrayBuffer();
                            if (storeId != tickStoreId) return;
                            const optUpdateBytes = new Uint8Array(data);

                            const mediaType = Module.stringToNewUTF8(response.headers.get('Content-Type'));
                            const consensusVersion = Module.stringToNewUTF8(response.headers.get('Eth-Consensus-Version'));
                            const optUpdateBytesPtr = Module._malloc(optUpdateBytes.length);
                            Module.HEAPU8.set(optUpdateBytes, optUpdateBytesPtr);
                            res = Module._ETHLightClientStoreProcessOptimisticUpdate(
                                store, cfg, forkDigests, genesisValRoot, beaconClock,
                                mediaType, consensusVersion, optUpdateBytesPtr, optUpdateBytes.length);
                            Module._free(optUpdateBytesPtr);
                            Module._free(consensusVersion);
                            Module._free(mediaType);
                        }
                    }

                    let millisecondsToNextSyncTask = Module._ETHLightClientStoreGetMillisecondsToNextSyncTask(
                        store, rng, beaconClock, res);
                    nextSyncTaskTime = Date.now() + millisecondsToNextSyncTask;
                    runOnTick(storeId, /* timeout: */ 100);
                }
                trackStoreTimeout = setTimeout(onTick, timeout);
            }

            const tickStoreId = storeId;
            setupSource(tickStoreId);
            runOnTick(tickStoreId, /* timeout: */ 0);
        }
        function clearStore() {
            if (trackStoreSource !== undefined) {
                trackStoreSource.close();
                trackStoreSource = undefined;
            }
            if (trackStoreTimeout !== undefined) {
                clearTimeout(trackStoreTimeout);
                trackStoreTimeout = undefined;
                nextSyncTaskTime = undefined;
            }
            if (store !== undefined) {
                Module._ETHLightClientStoreDestroy(store);
                store = undefined;
            }
        }

        const savedTrustedBlockRoot = localStorage.getItem('trustedBlockRoot');
        if (savedTrustedBlockRoot) {
            document.getElementById('trustedBlockRoot').value = savedTrustedBlockRoot;
        }

        Module.onRuntimeInitialized = async function() {
            Module._NimMain();

            rng = Module._ETHRandomNumberCreate();
            cfg = await loadCfg();
            const genesisState = await loadGenesis(cfg);
            genesisValRoot = Module._ETHBeaconStateCopyGenesisValidatorsRoot(genesisState);
            forkDigests = Module._ETHForkDigestsCreateFromState(cfg, genesisState);
            beaconClock = Module._ETHBeaconClockCreateFromState(genesisState);
            Module._ETHBeaconStateDestroy(genesisState);

            document.getElementById('initButton').addEventListener('click', async function() {
                const trustedBlockRootString = document.getElementById('trustedBlockRoot').value;
                if (!/^0x[0-9a-fA-F]{64}$/.test(trustedBlockRootString)) {
                    return;
                }
                document.getElementById('initButton').disabled = true;
                clearStore();

                beaconApiBase = document.getElementById('beaconApiBase').value;
                executionApiBase = document.getElementById('executionApiBase').value;
                const response = await fetch(beaconApiBase +
                    '/eth/v1/beacon/light_client/bootstrap/' + trustedBlockRootString, {
                        headers: {
                            'Accept': 'application/octet-stream'
                        }
                    });
                if (response.ok) {
                    const data = await response.arrayBuffer();
                    const bootstrapBytes = new Uint8Array(data);

                    const trustedBlockRootBytes = new Uint8Array(32);
                    for (let i = 0; i < trustedBlockRootBytes.length; i++) {
                        trustedBlockRootBytes[i] = parseInt(trustedBlockRootString.substr(i * 2 + 2, 2), 16);
                    }

                    const trustedBlockRootBytesPtr = Module._malloc(trustedBlockRootBytes.length);
                    Module.HEAPU8.set(trustedBlockRootBytes, trustedBlockRootBytesPtr);
                    const mediaType = Module.stringToNewUTF8(response.headers.get('Content-Type'));
                    const consensusVersion = Module.stringToNewUTF8(response.headers.get('Eth-Consensus-Version'));
                    const bootstrapBytesPtr = Module._malloc(bootstrapBytes.length);
                    Module.HEAPU8.set(bootstrapBytes, bootstrapBytesPtr);
                    const newStore = Module._ETHLightClientStoreCreateFromBootstrap(
                        cfg, trustedBlockRootBytesPtr,
                        mediaType, consensusVersion, bootstrapBytesPtr, bootstrapBytes.length);
                    Module._free(bootstrapBytesPtr);
                    Module._free(consensusVersion);
                    Module._free(trustedBlockRootBytesPtr);
                    Module._free(mediaType);

                    if (newStore) {
                        trackStore(newStore);

                        document.getElementById('settings').hidden = true;
                        document.getElementById('masterTop').hidden = false;
                        if (selectedHeader) {
                            document.getElementById('selectedHeaderDetail').hidden = false;
                        } else {
                            document.getElementById('headerList').hidden = false;
                        }
                    }
                }
                document.getElementById('initButton').disabled = false;
            });
            document.getElementById('initButton').disabled = false;
            document.getElementById('initButton').click();
        };
    </script>
    <script async src="libnimbus_lc.js"></script>
</body>
</html>
