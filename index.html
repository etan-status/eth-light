<!DOCTYPE html>
<html lang="en">
<head>
    <title>Ethereum Light</title>
    <style>
        #beaconApiBase, #trustedBlockRoot {
            width: 500px;
        }
        pre {
            display: inline;
        }
    </style>
</head>
<body>
    <h1>Bootstrap</h1>
    Current slot: <b><span id="wallSlot"></span></b><br />
    <br />
    Beacon-API base:<br /><input id="beaconApiBase" value="https://beacon-api.eth-light.xyz" /><br />
    <br />
    Checkpoint block root:<br /><input id="trustedBlockRoot" value="0x15cf56ebf887ede9cf3fc10a26ec83828628932c100e42c98c84f83da710c863" /><input type="button" id="initButton" value="Init" disabled /><br />
    <br />

    <h1>Sync progress</h1>
    <ul>
        <li>
            <pre>finalized_header</pre>
            <ul>
                <li>
                    <pre>beacon</pre>: <b><pre id="finalizedBeaconRoot"></pre></b>
                    <ul>
                        <li><pre>slot</pre>: <b><pre id="finalizedBeaconSlot"></pre></b></li>
                        <li><pre>proposer_index</pre>: <b><pre id="finalizedBeaconProposerIndex"></pre></b></li>
                        <li><pre>parent_root</pre>: <b><pre id="finalizedBeaconParentRoot"></pre></b></li>
                        <li><pre>state_root</pre>: <b><pre id="finalizedBeaconStateRoot"></pre></b></li>
                        <li><pre>body_root</pre>: <b><pre id="finalizedBeaconBodyRoot"></pre></b></li>
                    </ul>
                </li>
            </ul>
        </li>
        <li><pre>next_sync_committee</pre>: <b><pre id="nextSyncCommitteeKnown"></pre></b></li>
        <li>
            <pre>optimistic_header</pre>
            <ul>
                <li>
                    <pre>beacon</pre>: <b><pre id="optimisticBeaconRoot"></pre></b>
                    <ul>
                        <li><pre>slot</pre>: <b><pre id="optimisticBeaconSlot"></pre></b></li>
                        <li><pre>proposer_index</pre>: <b><pre id="optimisticBeaconProposerIndex"></pre></b></li>
                        <li><pre>parent_root</pre>: <b><pre id="optimisticBeaconParentRoot"></pre></b></li>
                        <li><pre>state_root</pre>: <b><pre id="optimisticBeaconStateRoot"></pre></b></li>
                        <li><pre>body_root</pre>: <b><pre id="optimisticBeaconBodyRoot"></pre></b></li>
                    </ul>
                </li>
            </ul>
        </li>
        <li><pre>safety_threshold</pre>: <b><pre id="safetyThreshold"></pre></b></li>
    </ul>
    Latest sync task: <b><span id="syncTask"></span></b><br />
    Next sync task: <b><span id="timeToNextSyncTask"></span></b><br />

    <script>
        const networkMetadataPath = 'https://raw.githubusercontent.com/eth-clients/eth2-networks/master/shared/mainnet';

        async function loadCfg() {
            const response = await fetch(networkMetadataPath + '/config.yaml');
            assert(response.ok);
            const data = await response.text();

            const fileContent = Module.stringToNewUTF8(data);
            const cfg = Module._ECLNetworkConfigCreateFromYaml(fileContent);
            assert(cfg);
            Module._free(fileContent);

            return cfg;
        }

        async function loadGenesis(cfg) {
            const consensusFork = Module._ECLNetworkConfigGetConsensusVersionAtEpoch(cfg, /* epoch: */ 0);
            const response = await fetch(networkMetadataPath + '/genesis.ssz');
            assert(response.ok);
            const data = await response.arrayBuffer();
            const sszBytes = new Uint8Array(data)

            const sszBytesPtr = Module._malloc(sszBytes.length);
            Module.HEAPU8.set(sszBytes, sszBytesPtr);
            const state = Module._ECLBeaconStateCreateFromSsz(cfg, consensusFork, sszBytesPtr, sszBytes.length);
            assert(state);
            Module._free(sszBytesPtr);

            return state;
        }

        let nextSyncTaskTime = undefined;
        function trackWallTime(beaconClock) {
            function onTick() {
                const slot = Module._ECLBeaconClockGetSlot(beaconClock);
                document.getElementById('wallSlot').innerText = slot;
                if (nextSyncTaskTime !== undefined) {
                    const now = Date.now();
                    let remainingMilliseconds = 0;
                    if (nextSyncTaskTime > now) {
                        remainingMilliseconds = nextSyncTaskTime - now;
                    }
                    const seconds = Math.floor((remainingMilliseconds / 1000) % 60).toString().padStart(2, '0');
                    const minutes = Math.floor((remainingMilliseconds / (1000 * 60)) % 60).toString().padStart(2, '0');
                    const hours = Math.floor((remainingMilliseconds / (1000 * 60 * 60)) % 24).toString().padStart(2, '0');
                    document.getElementById('timeToNextSyncTask').innerText =
                        hours + ':' + minutes + ':' + seconds;
                }
                setTimeout(onTick, /* timeout: */ 100);
            }
            setTimeout(onTick, /* timeout: */ 100);
        }

        var Module = {};

        function visualizeStore(store) {
            function toHexString(bytes, numBytes) {
                let hexString = '0x';
                for (let i = 0; i < numBytes; i++) {
                    let hexByte = Module.HEAPU8[bytes + i].toString(16);
                    if (hexByte.length === 1) hexByte = '0' + hexByte;
                    hexString += hexByte;
                }
                return hexString;
            }

            function visualizeHeader(prefix, header) {
                const beaconRoot = Module._ECLLightClientHeaderCopyBeaconRoot(header);
                document.getElementById(prefix + 'BeaconRoot').innerText = toHexString(beaconRoot, 32);
                Module._ECLRootDestroy(beaconRoot);
                const beacon = Module._ECLLightClientHeaderGetBeacon(header);
                const slot = Module._ECLBeaconBlockHeaderGetSlot(beacon);
                document.getElementById(prefix + 'BeaconSlot').innerText = slot;
                const proposerIndex = Module._ECLBeaconBlockHeaderGetProposerIndex(beacon);
                document.getElementById(prefix + 'BeaconProposerIndex').innerText = proposerIndex;
                const parentRoot = Module._ECLBeaconBlockHeaderGetParentRoot(beacon);
                document.getElementById(prefix + 'BeaconParentRoot').innerText = toHexString(parentRoot, 32);
                const stateRoot = Module._ECLBeaconBlockHeaderGetStateRoot(beacon);
                document.getElementById(prefix + 'BeaconStateRoot').innerText = toHexString(stateRoot, 32);
                const bodyRoot = Module._ECLBeaconBlockHeaderGetBodyRoot(beacon);
                document.getElementById(prefix + 'BeaconBodyRoot').innerText = toHexString(bodyRoot, 32);
            }

            visualizeHeader('finalized', Module._ECLLightClientStoreGetFinalizedHeader(store));
            const isNextSyncCommitteeKnown = Module._ECLLightClientStoreIsNextSyncCommitteeKnown(store);
            document.getElementById('nextSyncCommitteeKnown').innerText = (isNextSyncCommitteeKnown ? 'known' : 'unknown');
            visualizeHeader('optimistic', Module._ECLLightClientStoreGetOptimisticHeader(store));
            const safetyThreshold = Module._ECLLightClientStoreGetSafetyThreshold(store);
            document.getElementById('safetyThreshold').innerText = safetyThreshold;
        }

        let beaconApiBase = undefined;
        let rng = undefined;
        let cfg = undefined;
        let genesisValidatorsRoot = undefined;
        let forkDigests = undefined;
        let beaconClock = undefined;
        let store = undefined;
        let storeId = 0;
        let trackStoreTimeout = undefined;
        let trackStoreSource = undefined;
        function trackStore(newStore) {
            store = newStore;
            storeId++;

            function setupSource(tickStoreId) {
                trackStoreSource = new EventSource(beaconApiBase +
                    '/eth/v1/events?topics=light_client_finality_update&topics=light_client_optimistic_update');

                trackStoreSource.addEventListener('light_client_finality_update', function (event) {
                    if (storeId != tickStoreId) return;
                    const mediaType = Module.stringToNewUTF8("application/json");
                    const finUpdatesBytesPtr = Module.stringToNewUTF8(event.data);
                    const numFinUpdateBytes = Module.lengthBytesUTF8(event.data);
                    const res = Module._ECLLightClientStoreProcessFinalityUpdate(
                        store, cfg, forkDigests, genesisValidatorsRoot, beaconClock,
                        mediaType, /* consensusVersion: */ 0, finUpdatesBytesPtr, numFinUpdateBytes);
                    Module._free(finUpdatesBytesPtr);
                    Module._free(mediaType);
                    visualizeStore(store);
                });

                trackStoreSource.addEventListener('light_client_optimistic_update', function (event) {
                    if (storeId != tickStoreId) return;
                    const mediaType = Module.stringToNewUTF8("application/json");
                    const optUpdateBytesPtr = Module.stringToNewUTF8(event.data);
                    const numOptUpdateBytes = Module.lengthBytesUTF8(event.data);
                    const res = Module._ECLLightClientStoreProcessOptimisticUpdate(
                        store, cfg, forkDigests, genesisValidatorsRoot, beaconClock,
                        mediaType, /* consensusVersion: */ 0, optUpdateBytesPtr, numOptUpdateBytes);
                    Module._free(optUpdateBytesPtr);
                    Module._free(mediaType);
                    visualizeStore(store);
                });
            }

            function runOnTick(tickStoreId, timeout) {
                visualizeStore(store);
                async function onTick() {
                    trackStoreTimeout = undefined;
                    nextSyncTaskTime = undefined;

                    const startPeriodPtr = Module._malloc(4);
                    const countPtr = Module._malloc(4);
                    const syncKind = Module._ECLLightClientStoreGetNextSyncTask(
                        store, beaconClock, startPeriodPtr, countPtr);
                    const startPeriod = Module.HEAPU32[startPeriodPtr >>> 2];
                    const count = Module.HEAPU32[countPtr >>> 2];
                    Module._free(countPtr);
                    Module._free(startPeriodPtr);

                    let res = 1;
                    if (syncKind == Module.HEAPU8[Module._kECLLcSyncKind_UpdatesByRange]) {
                        document.getElementById('syncTask').innerText = 'UpdatesByRange(' + startPeriod + ", " + count + ')';
                        const response = await fetch(beaconApiBase +
                            '/eth/v1/beacon/light_client/updates?start_period=' + startPeriod + '&count=' + count, {
                                headers: {
                                    'Accept': 'application/octet-stream'
                                }
                            });
                        if (storeId != tickStoreId) return;
                        if (response.ok) {
                            const data = await response.arrayBuffer();
                            if (storeId != tickStoreId) return;
                            const updatesByRangeBytes = new Uint8Array(data);

                            const mediaType = Module.stringToNewUTF8(response.headers.get('Content-Type'));
                            const updatesByRangeBytesPtr = Module._malloc(updatesByRangeBytes.length);
                            Module.HEAPU8.set(updatesByRangeBytes, updatesByRangeBytesPtr);
                            res = Module._ECLLightClientStoreProcessUpdatesByRange(
                                store, cfg, forkDigests, genesisValidatorsRoot, beaconClock,
                                startPeriod, count, mediaType, updatesByRangeBytesPtr, updatesByRangeBytes.length);
                            Module._free(updatesByRangeBytesPtr);
                            Module._free(mediaType);
                        }
                    } else if (syncKind == Module.HEAPU8[Module._kECLLcSyncKind_FinalityUpdate]) {
                        document.getElementById('syncTask').innerText = 'FinalityUpdate';
                        const response = await fetch(beaconApiBase +
                            '/eth/v1/beacon/light_client/finality_update', {
                                headers: {
                                    'Accept': 'application/octet-stream'
                                }
                            });
                        if (storeId != tickStoreId) return;
                        if (response.ok) {
                            const data = await response.arrayBuffer();
                            if (storeId != tickStoreId) return;
                            const finUpdateBytes = new Uint8Array(data);

                            const mediaType = Module.stringToNewUTF8(response.headers.get('Content-Type'));
                            const consensusVersion = Module.stringToNewUTF8(response.headers.get('Eth-Consensus-Version'));
                            const finUpdatesBytesPtr = Module._malloc(finUpdateBytes.length);
                            Module.HEAPU8.set(finUpdateBytes, finUpdatesBytesPtr);
                            res = Module._ECLLightClientStoreProcessFinalityUpdate(
                                store, cfg, forkDigests, genesisValidatorsRoot, beaconClock,
                                mediaType, consensusVersion, finUpdatesBytesPtr, finUpdateBytes.length);
                            Module._free(finUpdatesBytesPtr);
                            Module._free(consensusVersion);
                            Module._free(mediaType);
                        }
                    } else {
                        assert(syncKind == Module.HEAPU8[Module._kECLLcSyncKind_OptimisticUpdate]);
                        document.getElementById('syncTask').innerText = 'OptimisticUpdate';
                        const response = await fetch(beaconApiBase +
                            '/eth/v1/beacon/light_client/optimistic_update', {
                                headers: {
                                    'Accept': 'application/octet-stream'
                                }
                            });
                        if (storeId != tickStoreId) return;
                        if (response.ok) {
                            const data = await response.arrayBuffer();
                            if (storeId != tickStoreId) return;
                            const optUpdateBytes = new Uint8Array(data);

                            const mediaType = Module.stringToNewUTF8(response.headers.get('Content-Type'));
                            const consensusVersion = Module.stringToNewUTF8(response.headers.get('Eth-Consensus-Version'));
                            const optUpdateBytesPtr = Module._malloc(optUpdateBytes.length);
                            Module.HEAPU8.set(optUpdateBytes, optUpdateBytesPtr);
                            res = Module._ECLLightClientStoreProcessOptimisticUpdate(
                                store, cfg, forkDigests, genesisValidatorsRoot, beaconClock,
                                mediaType, consensusVersion, optUpdateBytesPtr, optUpdateBytes.length);
                            Module._free(optUpdateBytesPtr);
                            Module._free(consensusVersion);
                            Module._free(mediaType);
                        }
                    }

                    let millisecondsToNextSyncTask = Module._ECLLightClientStoreGetMillisecondsToNextSyncTask(
                        store, rng, beaconClock, res);
                    nextSyncTaskTime = Date.now() + millisecondsToNextSyncTask;
                    runOnTick(storeId, /* timeout: */ millisecondsToNextSyncTask);
                }
                trackStoreTimeout = setTimeout(onTick, timeout);
            }

            const tickStoreId = storeId;
            setupSource(tickStoreId);
            runOnTick(tickStoreId, /* timeout: */ 0);
        }
        function clearStore() {
            if (trackStoreSource !== undefined) {
                trackStoreSource.close();
                trackStoreSource = undefined;
            }
            if (trackStoreTimeout !== undefined) {
                clearTimeout(trackStoreTimeout);
                trackStoreTimeout = undefined;
                nextSyncTaskTime = undefined;
            }
            if (store !== undefined) {
                Module._ECLLightClientStoreDestroy(store);
                store = undefined;
            }
        }

        Module.onRuntimeInitialized = async function() {
            rng = Module._ECLRandomNumberCreate();
            cfg = await loadCfg();
            const genesisState = await loadGenesis(cfg);
            genesisValidatorsRoot = Module._ECLBeaconStateCopyGenesisValidatorsRoot(genesisState);
            forkDigests = Module._ECLForkDigestsCreateFromState(cfg, genesisState);
            beaconClock = Module._ECLBeaconClockCreateFromState(genesisState);
            Module._ECLBeaconStateDestroy(genesisState);
            trackWallTime(beaconClock);

            document.getElementById('initButton').addEventListener('click', async function() {
                const trustedBlockRootString = document.getElementById('trustedBlockRoot').value;
                if (!/^0x[0-9a-fA-F]{64}$/.test(trustedBlockRootString)) {
                    return;
                }
                document.getElementById('initButton').disabled = true;
                clearStore();

                beaconApiBase = document.getElementById('beaconApiBase').value;
                const response = await fetch(beaconApiBase +
                    '/eth/v1/beacon/light_client/bootstrap/' + trustedBlockRootString, {
                        headers: {
                            'Accept': 'application/octet-stream'
                        }
                    });
                if (response.ok) {
                    const data = await response.arrayBuffer();
                    const bootstrapBytes = new Uint8Array(data);

                    const trustedBlockRootBytes = new Uint8Array(32);
                    for (let i = 0; i < trustedBlockRootBytes.length; i++) {
                        trustedBlockRootBytes[i] = parseInt(trustedBlockRootString.substr(i * 2 + 2, 2), 16);
                    }

                    const trustedBlockRootBytesPtr = Module._malloc(trustedBlockRootBytes.length);
                    Module.HEAPU8.set(trustedBlockRootBytes, trustedBlockRootBytesPtr);
                    const mediaType = Module.stringToNewUTF8(response.headers.get('Content-Type'));
                    const consensusVersion = Module.stringToNewUTF8(response.headers.get('Eth-Consensus-Version'));
                    const bootstrapBytesPtr = Module._malloc(bootstrapBytes.length);
                    Module.HEAPU8.set(bootstrapBytes, bootstrapBytesPtr);
                    const newStore = Module._ECLLightClientStoreCreateFromBootstrap(
                        cfg, trustedBlockRootBytesPtr,
                        mediaType, consensusVersion, bootstrapBytesPtr, bootstrapBytes.length);
                    assert(newStore);
                    Module._free(bootstrapBytesPtr);
                    Module._free(consensusVersion);
                    Module._free(trustedBlockRootBytesPtr);
                    Module._free(mediaType);

                    trackStore(newStore);
                }
                document.getElementById('initButton').disabled = false;
            });
            document.getElementById('initButton').disabled = false;
        };
    </script>
    <script async src="nimbus_light_client_ffi.js"></script>
</body>
</html>
