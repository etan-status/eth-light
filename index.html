<!DOCTYPE html>
<html lang="en">
<head>
    <title>Ethereum Light</title>
    <style>
        #beaconApiBase, #trustedBlockRoot {
            width: 500px;
        }
        pre {
            display: inline;
        }
    </style>
</head>
<body>
    <h1>Bootstrap</h1>
    Current slot: <b><span id="wallSlot"></span></b><br />
    <br />
    Beacon-API base:<br /><input id="beaconApiBase" value="https://beacon-api.eth-light.xyz" /><br />
    <br />
    Checkpoint block root:<br /><input id="trustedBlockRoot" value="0x15cf56ebf887ede9cf3fc10a26ec83828628932c100e42c98c84f83da710c863" /><input type="button" id="initButton" value="Init" disabled /><br />
    <br />

    <h1>Sync progress</h1>
    Latest sync task: <b><span id="syncTask"></span></b><br />
    Next fetch: <b><span id="timeToNextFetch"></span></b><br />
    <ul>
        <li>
            <pre>finalized_header</pre>
            <ul>
                <li>
                    <pre>beacon</pre>: <b><pre id="finalizedBeaconRoot"></pre></b>
                    <ul>
                        <li><pre>slot</pre>: <b><pre id="finalizedBeaconSlot"></pre></b></li>
                        <li><pre>proposer_index</pre>: <b><pre id="finalizedBeaconProposerIndex"></pre></b></li>
                        <li><pre>parent_root</pre>: <b><pre id="finalizedBeaconParentRoot"></pre></b></li>
                        <li><pre>state_root</pre>: <b><pre id="finalizedBeaconStateRoot"></pre></b></li>
                        <li><pre>body_root</pre>: <b><pre id="finalizedBeaconBodyRoot"></pre></b></li>
                    </ul>
                </li>
            </ul>
        </li>
        <li>
            <pre>optimistic_header</pre>
            <ul>
                <li>
                    <pre>beacon</pre>: <b><pre id="optimisticBeaconRoot"></pre></b>
                    <ul>
                        <li><pre>slot</pre>: <b><pre id="optimisticBeaconSlot"></pre></b></li>
                        <li><pre>proposer_index</pre>: <b><pre id="optimisticBeaconProposerIndex"></pre></b></li>
                        <li><pre>parent_root</pre>: <b><pre id="optimisticBeaconParentRoot"></pre></b></li>
                        <li><pre>state_root</pre>: <b><pre id="optimisticBeaconStateRoot"></pre></b></li>
                        <li><pre>body_root</pre>: <b><pre id="optimisticBeaconBodyRoot"></pre></b></li>
                    </ul>
                </li>
            </ul>
        </li>
    </ul>

    <h1>Secure random number demo</h1>
    <input id="rngOutput" readonly /><input type="button" id="rngButton" value="Rand" />

    <script>
        const networkMetadataPath = 'https://raw.githubusercontent.com/eth-clients/eth2-networks/master/shared/mainnet';

        async function loadCfg() {
            const response = await fetch(networkMetadataPath + '/config.yaml');
            assert(response.ok);
            const data = await response.text();

            const fileContent = Module.stringToNewUTF8(data);
            const cfg = Module._ETHRuntimeConfigCreateFromYaml(fileContent);
            assert(cfg);
            Module._free(fileContent);

            return cfg;
        }

        async function loadGenesis(cfg) {
            const consensusFork = Module._ETHRuntimeConfigGetConsensusForkAtEpoch(cfg, /* epoch: */ 0);
            const response = await fetch(networkMetadataPath + '/genesis.ssz');
            assert(response.ok);
            const data = await response.arrayBuffer();
            const sszBytes = new Uint8Array(data)

            const sszBytesPtr = Module._malloc(sszBytes.length);
            Module.HEAPU8.set(sszBytes, sszBytesPtr);
            const state = Module._ETHBeaconStateCreateFromSsz(cfg, consensusFork, sszBytesPtr, sszBytes.length);
            assert(state);
            Module._free(sszBytesPtr);

            return state;
        }

        let nextFetchTime = undefined;
        function trackWallTime(beaconClock) {
            function onTick() {
                const slot = Module._ETHBeaconClockGetSlot(beaconClock);
                document.getElementById('wallSlot').innerText = slot;
                if (nextFetchTime !== undefined) {
                    const now = Date.now();
                    let remainingMilliseconds = 0;
                    if (nextFetchTime > now) {
                        remainingMilliseconds = nextFetchTime - now;
                    }
                    const seconds = Math.floor((remainingMilliseconds / 1000) % 60).toString().padStart(2, '0');
                    const minutes = Math.floor((remainingMilliseconds / (1000 * 60)) % 60).toString().padStart(2, '0');
                    const hours = Math.floor((remainingMilliseconds / (1000 * 60 * 60)) % 24).toString().padStart(2, '0');
                    document.getElementById('timeToNextFetch').innerText =
                        hours + ':' + minutes + ':' + seconds;
                }
                setTimeout(onTick, /* timeout: */ 100);
            }
            setTimeout(onTick, /* timeout: */ 100);
        }

        var Module = {};

        function visualizeStore(store) {
            function toHexString(bytes, numBytes) {
                let hexString = '0x';
                for (let i = 0; i < numBytes; i++) {
                    let hexByte = Module.HEAPU8[bytes + i].toString(16);
                    if (hexByte.length === 1) hexByte = '0' + hexByte;
                    hexString += hexByte;
                }
                return hexString;
            }

            function visualizeHeader(prefix, header) {
                const beacon = Module._ETHLightClientHeaderGetBeacon(header);
                const root = Module._malloc(32);
                Module._ETHBeaconBlockHeaderGetRoot(beacon, root);
                document.getElementById(prefix + 'BeaconRoot').innerText = toHexString(root, 32);
                Module._free(root);
                const slot = Module._ETHBeaconBlockHeaderGetSlot(beacon);
                document.getElementById(prefix + 'BeaconSlot').innerText = slot;
                const proposerIndex = Module._ETHBeaconBlockHeaderGetProposerIndex(beacon);
                document.getElementById(prefix + 'BeaconProposerIndex').innerText = proposerIndex;
                const parentRoot = Module._ETHBeaconBlockHeaderGetParentRoot(beacon);
                document.getElementById(prefix + 'BeaconParentRoot').innerText = toHexString(parentRoot, 32);
                const stateRoot = Module._ETHBeaconBlockHeaderGetStateRoot(beacon);
                document.getElementById(prefix + 'BeaconStateRoot').innerText = toHexString(stateRoot, 32);
                const bodyRoot = Module._ETHBeaconBlockHeaderGetBodyRoot(beacon);
                document.getElementById(prefix + 'BeaconBodyRoot').innerText = toHexString(bodyRoot, 32);
            }

            visualizeHeader('finalized', Module._ETHLightClientStoreGetFinalizedHeader(store));
            visualizeHeader('optimistic', Module._ETHLightClientStoreGetOptimisticHeader(store));
        }

        let beaconApiBase = undefined;
        let rng = undefined;
        let cfg = undefined;
        let genesisValidatorsRoot = undefined;
        let forkDigests = undefined;
        let beaconClock = undefined;
        let store = undefined;
        let storeId = 0;
        let trackStoreTimeout = undefined;
        function trackStore(newStore) {
            store = newStore;
            storeId++;
            function runOnTick(tickStoreId, timeout) {
                visualizeStore(store);
                async function onTick() {
                    trackStoreTimeout = undefined;
                    nextFetchTime = undefined;

                    const startPeriodPtr = Module._malloc(4);
                    const countPtr = Module._malloc(4);
                    const syncKind = Module._ETHLightClientStoreGetNextSyncTask(
                        store, beaconClock, startPeriodPtr, countPtr);
                    const startPeriod = Module.HEAPU32[startPeriodPtr >>> 2];
                    const count = Module.HEAPU32[countPtr >>> 2];
                    Module._free(countPtr);
                    Module._free(startPeriodPtr);

                    let res = 0;
                    let didProgress = 0;
                    if (syncKind == Module.HEAPU8[Module._kETHLCSyncKind_UpdatesByRange]) {
                        document.getElementById('syncTask').innerText = 'UpdatesByRange(' + startPeriod + ", " + count + ')';
                        const response = await fetch(beaconApiBase +
                            '/eth/v1/beacon/light_client/updates?start_period=' + startPeriod + '&count=' + count, {
                                headers: {
                                    'Accept': 'application/octet-stream'
                                }
                            });
                        const data = await response.arrayBuffer();
                        if (storeId != tickStoreId) return;
                        const updatesByRangeSszBytes = new Uint8Array(data);

                        const updatesByRangeSszBytesPtr = Module._malloc(updatesByRangeSszBytes.length);
                        Module.HEAPU8.set(updatesByRangeSszBytes, updatesByRangeSszBytesPtr);
                        const didProgressPtr = Module._malloc(4);
                        res = Module._ETHLightClientStoreProcessUpdatesByRange(
                            store, cfg, forkDigests, genesisValidatorsRoot, beaconClock,
                            startPeriod, count, updatesByRangeSszBytesPtr, updatesByRangeSszBytes.length,
                            didProgressPtr);
                        didProgress = Module.HEAPU32[didProgressPtr >>> 2];
                        Module._free(didProgressPtr);
                        Module._free(updatesByRangeSszBytesPtr);
                    } else if (syncKind == Module.HEAPU8[Module._kETHLCSyncKind_FinalityUpdate]) {
                        document.getElementById('syncTask').innerText = 'FinalityUpdate';
                        const response = await fetch(beaconApiBase +
                            '/eth/v1/beacon/light_client/finality_update', {
                                headers: {
                                    'Accept': 'application/octet-stream'
                                }
                            });
                        const data = await response.arrayBuffer();
                        if (storeId != tickStoreId) return;
                        const finalityUpdateSszBytes = new Uint8Array(data);

                        const ethConsensusVersion = Module.stringToNewUTF8(response.headers.get('Eth-Consensus-Version'));
                        const finalityUpdateSszBytesPtr = Module._malloc(finalityUpdateSszBytes.length);
                        Module.HEAPU8.set(finalityUpdateSszBytes, finalityUpdateSszBytesPtr);
                        const didProgressPtr = Module._malloc(4);
                        res = Module._ETHLightClientStoreProcessFinalityUpdate(
                            store, cfg, forkDigests, genesisValidatorsRoot, beaconClock,
                            ethConsensusVersion, finalityUpdateSszBytesPtr, finalityUpdateSszBytes.length,
                            didProgressPtr);
                        didProgress = Module.HEAPU32[didProgressPtr >>> 2];
                        Module._free(didProgressPtr);
                        Module._free(finalityUpdateSszBytesPtr);
                        Module._free(ethConsensusVersion);
                    } else {
                        assert(syncKind == Module.HEAPU8[Module._kETHLCSyncKind_OptimisticUpdate]);
                        document.getElementById('syncTask').innerText = 'OptimisticUpdate';
                        const response = await fetch(beaconApiBase +
                            '/eth/v1/beacon/light_client/optimistic_update', {
                                headers: {
                                    'Accept': 'application/octet-stream'
                                }
                            });
                        const data = await response.arrayBuffer();
                        if (storeId != tickStoreId) return;
                        const optimisticUpdateSszBytes = new Uint8Array(data);

                        const ethConsensusVersion = Module.stringToNewUTF8(response.headers.get('Eth-Consensus-Version'));
                        const optimisticUpdateSszBytesPtr = Module._malloc(optimisticUpdateSszBytes.length);
                        Module.HEAPU8.set(optimisticUpdateSszBytes, optimisticUpdateSszBytesPtr);
                        const didProgressPtr = Module._malloc(4);
                        res = Module._ETHLightClientStoreProcessOptimisticUpdate(
                            store, cfg, forkDigests, genesisValidatorsRoot, beaconClock,
                            ethConsensusVersion, optimisticUpdateSszBytesPtr, optimisticUpdateSszBytes.length,
                            didProgressPtr);
                        didProgress = Module.HEAPU32[didProgressPtr >>> 2];
                        Module._free(didProgressPtr);
                        Module._free(optimisticUpdateSszBytesPtr);
                        Module._free(ethConsensusVersion);
                    }

                    let millisecondsToNextFetch = 0;
                    if (res) {
                        millisecondsToNextFetch = 15 * 60 * 1000;
                    } else if (!didProgress) {
                        millisecondsToNextFetch = 15 * 1000;
                    } else {
                        millisecondsToNextFetch = Module._ETHLightClientStoreGetMillisecondsToNextFetch(
                            store, rng, beaconClock,
                            syncKind == Module.HEAPU8[Module._kETHLCSyncKind_OptimisticUpdate]);
                    }
                    nextFetchTime = Date.now() + millisecondsToNextFetch;
                    runOnTick(storeId, /* timeout: */ millisecondsToNextFetch);
                }
                trackStoreTimeout = setTimeout(onTick, timeout);
            }
            runOnTick(storeId, /* timeout: */ 0);
        }
        function clearStore() {
            if (trackStoreTimeout !== undefined) {
                clearTimeout(trackStoreTimeout);
                trackStoreTimeout = undefined;
                nextFetchTime = undefined;
            }
            if (store !== undefined) {
                Module._ETHLightClientStoreDestroy(store);
                store = undefined;
            }
        }

        Module.onRuntimeInitialized = async function() {
            rng = Module._ETHRandomNumberCreate();
            cfg = await loadCfg();
            const genesisState = await loadGenesis(cfg);
            genesisValidatorsRoot = Module._ETHBeaconStateCopyGenesisValidatorsRoot(genesisState);
            forkDigests = Module._ETHForkDigestsCreateFromState(cfg, genesisState);
            beaconClock = Module._ETHBeaconClockCreateFromState(genesisState);
            Module._ETHBeaconStateDestroy(genesisState);
            trackWallTime(beaconClock);

            document.getElementById('rngButton').addEventListener('click', function() {
                document.getElementById('rngOutput').value = Module._ETHRandomNumberGet(rng);
            })

            document.getElementById('initButton').addEventListener('click', async function() {
                const trustedBlockRootString = document.getElementById('trustedBlockRoot').value;
                if (!/^0x[0-9a-fA-F]{64}$/.test(trustedBlockRootString)) {
                    return;
                }
                document.getElementById('initButton').disabled = true;
                clearStore();

                beaconApiBase = document.getElementById('beaconApiBase').value;
                const response = await fetch(beaconApiBase +
                    '/eth/v1/beacon/light_client/bootstrap/' + trustedBlockRootString, {
                        headers: {
                            'Accept': 'application/octet-stream'
                        }
                    });
                if (response.ok) {
                    const data = await response.arrayBuffer();
                    const bootstrapSszBytes = new Uint8Array(data);

                    const trustedBlockRootBytes = new Uint8Array(32);
                    for (let i = 0; i < trustedBlockRootBytes.length; i++) {
                        trustedBlockRootBytes[i] = parseInt(trustedBlockRootString.substr(i * 2 + 2, 2), 16);
                    }

                    const trustedBlockRootBytesPtr = Module._malloc(trustedBlockRootBytes.length);
                    Module.HEAPU8.set(trustedBlockRootBytes, trustedBlockRootBytesPtr);
                    const ethConsensusVersion = Module.stringToNewUTF8(response.headers.get('Eth-Consensus-Version'));
                    const bootstrapSszBytesPtr = Module._malloc(bootstrapSszBytes.length);
                    Module.HEAPU8.set(bootstrapSszBytes, bootstrapSszBytesPtr);
                    const newStore = Module._ETHLightClientStoreCreateFromBootstrap(
                        cfg, trustedBlockRootBytesPtr,
                        ethConsensusVersion, bootstrapSszBytesPtr, bootstrapSszBytes.length);
                    assert(newStore);
                    Module._free(bootstrapSszBytesPtr);
                    Module._free(ethConsensusVersion);
                    Module._free(trustedBlockRootBytesPtr);

                    trackStore(newStore);
                }
                document.getElementById('initButton').disabled = false;
            });
            document.getElementById('initButton').disabled = false;
        };
    </script>
    <script async src="light_client_wasm.js"></script>
</body>
</html>
