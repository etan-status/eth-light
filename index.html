<!DOCTYPE html>
<html lang="en">
<head>
    <title>Ethereum Light</title>
    <style>
        #beaconApiBase, #trustedBlockRoot {
            width: 500px;
        }
        pre {
            display: inline;
        }
    </style>
</head>
<body>
    <h1>Bootstrap</h1>
    Current slot: <b><span id="wallSlot"></span></b><br />
    <br />
    Beacon-API base:<br /><input id="beaconApiBase" value="https://beacon-api.eth-light.xyz" /><br />
    <br />
    Checkpoint block root:<br /><input id="trustedBlockRoot" value="0x15cf56ebf887ede9cf3fc10a26ec83828628932c100e42c98c84f83da710c863" /><input type="button" id="initButton" value="Init" disabled /><br />
    <br />

    <h1>Sync progress</h1>
    <ul>
        <li>
            <pre>finalized_header</pre>
            <ul>
                <li>
                    <pre>beacon</pre>: <b><pre id="finalizedBeaconRoot"></pre></b>
                    <ul>
                        <li><pre>slot</pre>: <b><pre id="finalizedBeaconSlot"></pre></b></li>
                        <li><pre>proposer_index</pre>: <b><pre id="finalizedBeaconProposerIndex"></pre></b></li>
                        <li><pre>parent_root</pre>: <b><pre id="finalizedBeaconParentRoot"></pre></b></li>
                        <li><pre>state_root</pre>: <b><pre id="finalizedBeaconStateRoot"></pre></b></li>
                        <li><pre>body_root</pre>: <b><pre id="finalizedBeaconBodyRoot"></pre></b></li>
                    </ul>
                </li>
                <li>
                    <pre>execution</pre>: <b><pre id="finalizedExecutionHash"></pre></b>
                    <ul>
                        <li><pre>parent_hash</pre>: <b><pre id="finalizedExecutionParentHash"></pre></b></li>
                        <li><pre>fee_recipient</pre>: <b><pre id="finalizedExecutionFeeRecipient"></pre></b></li>
                        <li><pre>state_root</pre>: <b><pre id="finalizedExecutionStateRoot"></pre></b></li>
                        <li><pre>receipts_root</pre>: <b><pre id="finalizedExecutionReceiptsRoot"></pre></b></li>
                        <li><pre>logs_bloom</pre>: <b><pre id="finalizedExecutionLogsBloom"></pre></b></li>
                        <li><pre>prev_randao</pre>: <b><pre id="finalizedExecutionPrevRandao"></pre></b></li>
                        <li><pre>block_number</pre>: <b><pre id="finalizedExecutionBlockNumber"></pre></b></li>
                        <li><pre>gas_limit</pre>: <b><pre id="finalizedExecutionGasLimit"></pre></b></li>
                        <li><pre>gas_used</pre>: <b><pre id="finalizedExecutionGasUsed"></pre></b></li>
                        <li><pre>timestamp</pre>: <b><pre id="finalizedExecutionTimestamp"></pre></b></li>
                        <li><pre>extra_data</pre>: <b><pre id="finalizedExecutionExtraData"></pre></b></li>
                        <li><pre>base_fee_per_gas</pre>: <b><pre id="finalizedExecutionBaseFeePerGas"></pre></b></li>
                        <li><pre>data_gas_used</pre>: <b><pre id="finalizedExecutionDataGasUsed"></pre></b></li>
                        <li><pre>excess_data_gas</pre>: <b><pre id="finalizedExecutionExcessDataGas"></pre></b></li>
                    </ul>
                </li>
            </ul>
        </li>
        <li><pre>next_sync_committee</pre>: <b><pre id="nextSyncCommitteeKnown"></pre></b></li>
        <li>
            <pre>optimistic_header</pre>
            <ul>
                <li>
                    <pre>beacon</pre>: <b><pre id="optimisticBeaconRoot"></pre></b>
                    <ul>
                        <li><pre>slot</pre>: <b><pre id="optimisticBeaconSlot"></pre></b></li>
                        <li><pre>proposer_index</pre>: <b><pre id="optimisticBeaconProposerIndex"></pre></b></li>
                        <li><pre>parent_root</pre>: <b><pre id="optimisticBeaconParentRoot"></pre></b></li>
                        <li><pre>state_root</pre>: <b><pre id="optimisticBeaconStateRoot"></pre></b></li>
                        <li><pre>body_root</pre>: <b><pre id="optimisticBeaconBodyRoot"></pre></b></li>
                    </ul>
                </li>
                <li>
                    <pre>execution</pre>: <b><pre id="optimisticExecutionHash"></pre></b>
                    <ul>
                        <li><pre>parent_hash</pre>: <b><pre id="optimisticExecutionParentHash"></pre></b></li>
                        <li><pre>fee_recipient</pre>: <b><pre id="optimisticExecutionFeeRecipient"></pre></b></li>
                        <li><pre>state_root</pre>: <b><pre id="optimisticExecutionStateRoot"></pre></b></li>
                        <li><pre>receipts_root</pre>: <b><pre id="optimisticExecutionReceiptsRoot"></pre></b></li>
                        <li><pre>logs_bloom</pre>: <b><pre id="optimisticExecutionLogsBloom"></pre></b></li>
                        <li><pre>prev_randao</pre>: <b><pre id="optimisticExecutionPrevRandao"></pre></b></li>
                        <li><pre>block_number</pre>: <b><pre id="optimisticExecutionBlockNumber"></pre></b></li>
                        <li><pre>gas_limit</pre>: <b><pre id="optimisticExecutionGasLimit"></pre></b></li>
                        <li><pre>gas_used</pre>: <b><pre id="optimisticExecutionGasUsed"></pre></b></li>
                        <li><pre>timestamp</pre>: <b><pre id="optimisticExecutionTimestamp"></pre></b></li>
                        <li><pre>extra_data</pre>: <b><pre id="optimisticExecutionExtraData"></pre></b></li>
                        <li><pre>base_fee_per_gas</pre>: <b><pre id="optimisticExecutionBaseFeePerGas"></pre></b></li>
                        <li><pre>data_gas_used</pre>: <b><pre id="optimisticExecutionDataGasUsed"></pre></b></li>
                        <li><pre>excess_data_gas</pre>: <b><pre id="optimisticExecutionExcessDataGas"></pre></b></li>
                    </ul>
                </li>
            </ul>
        </li>
        <li><pre>safety_threshold</pre>: <b><pre id="safetyThreshold"></pre></b></li>
    </ul>
    Latest sync task: <b><span id="syncTask"></span></b><br />
    Next sync task: <b><span id="timeToNextSyncTask"></span></b><br />
    <br />

    <h1>History</h1>
    <ul id="headersHistory"></ul>

    <script>
        const networkMetadataPath = 'https://raw.githubusercontent.com/eth-clients/eth2-networks/master/shared/mainnet';

        async function loadCfg() {
            const response = await fetch(networkMetadataPath + '/config.yaml');
            assert(response.ok);
            const data = await response.text();

            const fileContent = Module.stringToNewUTF8(data);
            const cfg = Module._ETHConsensusConfigCreateFromYaml(fileContent);
            assert(cfg);
            Module._free(fileContent);

            return cfg;
        }

        async function loadGenesis(cfg) {
            const consensusFork = Module._ETHConsensusConfigGetConsensusVersionAtEpoch(cfg, /* epoch: */ 0);
            const response = await fetch(networkMetadataPath + '/genesis.ssz');
            assert(response.ok);
            const data = await response.arrayBuffer();
            const sszBytes = new Uint8Array(data)

            const sszBytesPtr = Module._malloc(sszBytes.length);
            Module.HEAPU8.set(sszBytes, sszBytesPtr);
            const state = Module._ETHBeaconStateCreateFromSsz(cfg, consensusFork, sszBytesPtr, sszBytes.length);
            assert(state);
            Module._free(sszBytesPtr);

            return state;
        }

        let nextSyncTaskTime = undefined;
        function trackWallTime(beaconClock) {
            function onTick() {
                const slot = Module._ETHBeaconClockGetSlot(beaconClock);
                document.getElementById('wallSlot').innerText = slot;
                if (nextSyncTaskTime !== undefined) {
                    const now = Date.now();
                    let remainingMilliseconds = 0;
                    if (nextSyncTaskTime > now) {
                        remainingMilliseconds = nextSyncTaskTime - now;
                    }
                    const seconds = Math.floor((remainingMilliseconds / 1000) % 60).toString().padStart(2, '0');
                    const minutes = Math.floor((remainingMilliseconds / (1000 * 60)) % 60).toString().padStart(2, '0');
                    const hours = Math.floor((remainingMilliseconds / (1000 * 60 * 60)) % 24).toString().padStart(2, '0');
                    document.getElementById('timeToNextSyncTask').innerText =
                        hours + ':' + minutes + ':' + seconds;
                }
                setTimeout(onTick, /* timeout: */ 100);
            }
            setTimeout(onTick, /* timeout: */ 100);
        }

        var Module = {};

        function toHexString(bytes, numBytes) {
            const array = Array.from(Module.HEAPU8.subarray(bytes, bytes + numBytes))
            return '0x' + array.reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');
        }

        function getBeaconRootString(header) {
            const beaconRoot = Module._ETHLightClientHeaderCopyBeaconRoot(header, cfg);
            const beaconRootString = toHexString(beaconRoot, 32);
            Module._ETHRootDestroy(beaconRoot);
            return beaconRootString;
        }

        function getBeaconSlot(header) {
            const beacon = Module._ETHLightClientHeaderGetBeacon(header);
            return Module._ETHBeaconBlockHeaderGetSlot(beacon);
        }

        function initHeadersCache() {
            let headers = [];
            let byRoot = {};

            return {
                'add': function(header, cfg) {
                    const beaconRootString = getBeaconRootString(header);
                    if (byRoot[beaconRootString]) {
                        return;
                    }

                    const beaconSlot = getBeaconSlot(header);
                    const i = headers.findIndex(x => beaconSlot > getBeaconSlot(x));
                    const copy = Module._ETHLightClientHeaderCreateCopy(header)
                    headers.splice(i >= 0 ? i : headers.length, 0, copy);
                    byRoot[beaconRootString] = copy;

                    if (headers.length > 128) {
                        const removedHeader = headers.pop();
                        const removedBeaconRootString = getBeaconRootString(removedHeader);
                        delete byRoot[removedBeaconRootString];
                        Module._ETHLightClientHeaderDestroy(removedHeader);
                    }
                },

                'getAll': function() {
                    return headers;
                }
            }
        }

        let headers = initHeadersCache();

        function cacheHeaders(store, cfg) {
            headers.add(Module._ETHLightClientStoreGetOptimisticHeader(store), cfg);
            headers.add(Module._ETHLightClientStoreGetFinalizedHeader(store), cfg);

            const ul = document.getElementById('headersHistory');
            while (ul.firstChild) {
                ul.removeChild(ul.firstChild);
            }
            for (const header of headers.getAll()) {
                const li = document.createElement('li');
                li.textContent = '' + getBeaconSlot(header) + ' (' + getBeaconRootString(header) + ')';
                ul.appendChild(li);
            }
        }

        function visualizeStore(store, cfg) {
            function toGweiString(weiU256Bytes) {
                const array = Array.from(Module.HEAPU8.subarray(weiU256Bytes, weiU256Bytes + 32)).reverse();
                const wei = BigInt('0x' + array.reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), ''));
                const weiString = wei.toString();
                const beforeDecimal = weiString.substring(0, weiString.length - 9);
                const afterDecimal = weiString.substring(weiString.length - 9).replace(/0+$/, '');
                let gweiString = '';
                if (beforeDecimal === '') {
                    gweiString = '0.' + afterDecimal;
                } else {
                    gweiString = beforeDecimal + '.' + afterDecimal;
                }
                return gweiString;
            }

            function visualizeHeader(prefix, header) {
                const beaconRoot = Module._ETHLightClientHeaderCopyBeaconRoot(header, cfg);
                document.getElementById(prefix + 'BeaconRoot').innerText = toHexString(beaconRoot, 32);
                Module._ETHRootDestroy(beaconRoot);
                const beacon = Module._ETHLightClientHeaderGetBeacon(header);
                const beaconSlot = Module._ETHBeaconBlockHeaderGetSlot(beacon);
                document.getElementById(prefix + 'BeaconSlot').innerText = beaconSlot;
                const beaconProposerIndex = Module._ETHBeaconBlockHeaderGetProposerIndex(beacon);
                document.getElementById(prefix + 'BeaconProposerIndex').innerText = beaconProposerIndex;
                const beaconParentRoot = Module._ETHBeaconBlockHeaderGetParentRoot(beacon);
                document.getElementById(prefix + 'BeaconParentRoot').innerText = toHexString(beaconParentRoot, 32);
                const beaconStateRoot = Module._ETHBeaconBlockHeaderGetStateRoot(beacon);
                document.getElementById(prefix + 'BeaconStateRoot').innerText = toHexString(beaconStateRoot, 32);
                const beaconBodyRoot = Module._ETHBeaconBlockHeaderGetBodyRoot(beacon);
                document.getElementById(prefix + 'BeaconBodyRoot').innerText = toHexString(beaconBodyRoot, 32);

                const executionHash = Module._ETHLightClientHeaderCopyExecutionHash(header, cfg);
                document.getElementById(prefix + 'ExecutionHash').innerText = toHexString(executionHash, 32);
                Module._ETHRootDestroy(executionHash);
                const execution = Module._ETHLightClientHeaderGetExecution(header);
                const executionParentHash = Module._ETHExecutionPayloadHeaderGetParentHash(execution);
                document.getElementById(prefix + 'ExecutionParentHash').innerText = toHexString(executionParentHash, 32);
                const executionFeeRecipient = Module._ETHExecutionPayloadHeaderGetFeeRecipient(execution);
                document.getElementById(prefix + 'ExecutionFeeRecipient').innerText = toHexString(executionFeeRecipient, 20);
                const executionStateRoot = Module._ETHExecutionPayloadHeaderGetStateRoot(execution);
                document.getElementById(prefix + 'ExecutionStateRoot').innerText = toHexString(executionStateRoot, 32);
                const executionReceiptsRoot = Module._ETHExecutionPayloadHeaderGetReceiptsRoot(execution);
                document.getElementById(prefix + 'ExecutionReceiptsRoot').innerText = toHexString(executionReceiptsRoot, 32);
                const executionLogsBloom = Module._ETHExecutionPayloadHeaderGetLogsBloom(execution);
                document.getElementById(prefix + 'ExecutionLogsBloom').innerText = toHexString(executionLogsBloom, 256);
                const executionPrevRandao = Module._ETHExecutionPayloadHeaderGetPrevRandao(execution);
                document.getElementById(prefix + 'ExecutionPrevRandao').innerText = toHexString(executionPrevRandao, 32);
                const executionBlockNumber = Module._ETHExecutionPayloadHeaderGetBlockNumber(execution);
                document.getElementById(prefix + 'ExecutionBlockNumber').innerText = executionBlockNumber;
                const executionGasLimit = Module._ETHExecutionPayloadHeaderGetGasLimit(execution);
                document.getElementById(prefix + 'ExecutionGasLimit').innerText = executionGasLimit;
                const executionGasUsed = Module._ETHExecutionPayloadHeaderGetGasUsed(execution);
                document.getElementById(prefix + 'ExecutionGasUsed').innerText = executionGasUsed;
                const executionTimestamp = Module._ETHExecutionPayloadHeaderGetTimestamp(execution);
                document.getElementById(prefix + 'ExecutionTimestamp').innerText = executionTimestamp;
                const executionExtraDataBytes = Module._ETHExecutionPayloadHeaderGetExtraDataBytes(execution);
                const numExecutionExtraDataBytes = Module._ETHExecutionPayloadHeaderGetNumExtraDataBytes(execution);
                document.getElementById(prefix + 'ExecutionExtraData').innerText = toHexString(executionExtraDataBytes, numExecutionExtraDataBytes);
                const executionBaseFeePerGas = Module._ETHExecutionPayloadHeaderGetBaseFeePerGas(execution);
                document.getElementById(prefix + 'ExecutionBaseFeePerGas').innerText = toGweiString(executionBaseFeePerGas) + ' Gwei';
                const executionDataGasUsed = Module._ETHExecutionPayloadHeaderGetDataGasUsed(execution);
                document.getElementById(prefix + 'ExecutionDataGasUsed').innerText = executionDataGasUsed;
                const executionExcessDataGas = Module._ETHExecutionPayloadHeaderGetExcessDataGas(execution);
                document.getElementById(prefix + 'ExecutionExcessDataGas').innerText = executionExcessDataGas;
            }

            visualizeHeader('finalized', Module._ETHLightClientStoreGetFinalizedHeader(store));
            const isNextSyncCommitteeKnown = Module._ETHLightClientStoreIsNextSyncCommitteeKnown(store);
            document.getElementById('nextSyncCommitteeKnown').innerText = (isNextSyncCommitteeKnown ? 'known' : 'unknown');
            visualizeHeader('optimistic', Module._ETHLightClientStoreGetOptimisticHeader(store));
            const safetyThreshold = Module._ETHLightClientStoreGetSafetyThreshold(store);
            document.getElementById('safetyThreshold').innerText = safetyThreshold;
        }

        let beaconApiBase = undefined;
        let rng = undefined;
        let cfg = undefined;
        let genesisValRoot = undefined;
        let forkDigests = undefined;
        let beaconClock = undefined;
        let store = undefined;
        let storeId = 0;
        let trackStoreTimeout = undefined;
        let trackStoreSource = undefined;
        function trackStore(newStore) {
            store = newStore;
            storeId++;

            function setupSource(tickStoreId) {
                trackStoreSource = new EventSource(beaconApiBase +
                    '/eth/v1/events?topics=light_client_finality_update&topics=light_client_optimistic_update');

                trackStoreSource.addEventListener('light_client_finality_update', function (event) {
                    if (storeId != tickStoreId) return;
                    const mediaType = Module.stringToNewUTF8("application/json");
                    const finUpdatesBytesPtr = Module.stringToNewUTF8(event.data);
                    const numFinUpdateBytes = Module.lengthBytesUTF8(event.data);
                    const res = Module._ETHLightClientStoreProcessFinalityUpdate(
                        store, cfg, forkDigests, genesisValRoot, beaconClock,
                        mediaType, /* consensusVersion: */ 0, finUpdatesBytesPtr, numFinUpdateBytes);
                    Module._free(finUpdatesBytesPtr);
                    Module._free(mediaType);
                    cacheHeaders(store, cfg);
                    visualizeStore(store, cfg);
                });

                trackStoreSource.addEventListener('light_client_optimistic_update', function (event) {
                    if (storeId != tickStoreId) return;
                    const mediaType = Module.stringToNewUTF8("application/json");
                    const optUpdateBytesPtr = Module.stringToNewUTF8(event.data);
                    const numOptUpdateBytes = Module.lengthBytesUTF8(event.data);
                    const res = Module._ETHLightClientStoreProcessOptimisticUpdate(
                        store, cfg, forkDigests, genesisValRoot, beaconClock,
                        mediaType, /* consensusVersion: */ 0, optUpdateBytesPtr, numOptUpdateBytes);
                    Module._free(optUpdateBytesPtr);
                    Module._free(mediaType);
                    cacheHeaders(store, cfg);
                    visualizeStore(store, cfg);
                });
            }

            function runOnTick(tickStoreId, timeout) {
                cacheHeaders(store, cfg);
                visualizeStore(store, cfg);
                async function onTick() {
                    trackStoreTimeout = undefined;
                    nextSyncTaskTime = undefined;

                    const startPeriodPtr = Module._malloc(4);
                    const countPtr = Module._malloc(4);
                    const syncKind = Module._ETHLightClientStoreGetNextSyncTask(
                        store, beaconClock, startPeriodPtr, countPtr);
                    const startPeriod = Module.HEAPU32[startPeriodPtr >>> 2];
                    const count = Module.HEAPU32[countPtr >>> 2];
                    Module._free(countPtr);
                    Module._free(startPeriodPtr);

                    let res = 1;
                    if (syncKind == Module.HEAPU8[Module._kETHLcSyncKind_UpdatesByRange]) {
                        document.getElementById('syncTask').innerText = 'UpdatesByRange(' + startPeriod + ", " + count + ')';
                        const response = await fetch(beaconApiBase +
                            '/eth/v1/beacon/light_client/updates?start_period=' + startPeriod + '&count=' + count, {
                                headers: {
                                    'Accept': 'application/octet-stream'
                                }
                            });
                        if (storeId != tickStoreId) return;
                        if (response.ok) {
                            const data = await response.arrayBuffer();
                            if (storeId != tickStoreId) return;
                            const updatesBytes = new Uint8Array(data);

                            const mediaType = Module.stringToNewUTF8(response.headers.get('Content-Type'));
                            const updatesBytesPtr = Module._malloc(updatesBytes.length);
                            Module.HEAPU8.set(updatesBytes, updatesBytesPtr);
                            res = Module._ETHLightClientStoreProcessUpdatesByRange(
                                store, cfg, forkDigests, genesisValRoot, beaconClock,
                                startPeriod, count, mediaType, updatesBytesPtr, updatesBytes.length);
                            Module._free(updatesBytesPtr);
                            Module._free(mediaType);
                        }
                    } else if (syncKind == Module.HEAPU8[Module._kETHLcSyncKind_FinalityUpdate]) {
                        document.getElementById('syncTask').innerText = 'FinalityUpdate';
                        const response = await fetch(beaconApiBase +
                            '/eth/v1/beacon/light_client/finality_update', {
                                headers: {
                                    'Accept': 'application/octet-stream'
                                }
                            });
                        if (storeId != tickStoreId) return;
                        if (response.ok) {
                            const data = await response.arrayBuffer();
                            if (storeId != tickStoreId) return;
                            const finUpdateBytes = new Uint8Array(data);

                            const mediaType = Module.stringToNewUTF8(response.headers.get('Content-Type'));
                            const consensusVersion = Module.stringToNewUTF8(response.headers.get('Eth-Consensus-Version'));
                            const finUpdatesBytesPtr = Module._malloc(finUpdateBytes.length);
                            Module.HEAPU8.set(finUpdateBytes, finUpdatesBytesPtr);
                            res = Module._ETHLightClientStoreProcessFinalityUpdate(
                                store, cfg, forkDigests, genesisValRoot, beaconClock,
                                mediaType, consensusVersion, finUpdatesBytesPtr, finUpdateBytes.length);
                            Module._free(finUpdatesBytesPtr);
                            Module._free(consensusVersion);
                            Module._free(mediaType);
                        }
                    } else {
                        assert(syncKind == Module.HEAPU8[Module._kETHLcSyncKind_OptimisticUpdate]);
                        document.getElementById('syncTask').innerText = 'OptimisticUpdate';
                        const response = await fetch(beaconApiBase +
                            '/eth/v1/beacon/light_client/optimistic_update', {
                                headers: {
                                    'Accept': 'application/octet-stream'
                                }
                            });
                        if (storeId != tickStoreId) return;
                        if (response.ok) {
                            const data = await response.arrayBuffer();
                            if (storeId != tickStoreId) return;
                            const optUpdateBytes = new Uint8Array(data);

                            const mediaType = Module.stringToNewUTF8(response.headers.get('Content-Type'));
                            const consensusVersion = Module.stringToNewUTF8(response.headers.get('Eth-Consensus-Version'));
                            const optUpdateBytesPtr = Module._malloc(optUpdateBytes.length);
                            Module.HEAPU8.set(optUpdateBytes, optUpdateBytesPtr);
                            res = Module._ETHLightClientStoreProcessOptimisticUpdate(
                                store, cfg, forkDigests, genesisValRoot, beaconClock,
                                mediaType, consensusVersion, optUpdateBytesPtr, optUpdateBytes.length);
                            Module._free(optUpdateBytesPtr);
                            Module._free(consensusVersion);
                            Module._free(mediaType);
                        }
                    }

                    let millisecondsToNextSyncTask = Module._ETHLightClientStoreGetMillisecondsToNextSyncTask(
                        store, rng, beaconClock, res);
                    nextSyncTaskTime = Date.now() + millisecondsToNextSyncTask;
                    runOnTick(storeId, /* timeout: */ millisecondsToNextSyncTask);
                }
                trackStoreTimeout = setTimeout(onTick, timeout);
            }

            const tickStoreId = storeId;
            setupSource(tickStoreId);
            runOnTick(tickStoreId, /* timeout: */ 0);
        }
        function clearStore() {
            if (trackStoreSource !== undefined) {
                trackStoreSource.close();
                trackStoreSource = undefined;
            }
            if (trackStoreTimeout !== undefined) {
                clearTimeout(trackStoreTimeout);
                trackStoreTimeout = undefined;
                nextSyncTaskTime = undefined;
            }
            if (store !== undefined) {
                Module._ETHLightClientStoreDestroy(store);
                store = undefined;
            }
        }

        Module.onRuntimeInitialized = async function() {
            rng = Module._ETHRandomNumberCreate();
            cfg = await loadCfg();
            const genesisState = await loadGenesis(cfg);
            genesisValRoot = Module._ETHBeaconStateCopyGenesisValidatorsRoot(genesisState);
            forkDigests = Module._ETHForkDigestsCreateFromState(cfg, genesisState);
            beaconClock = Module._ETHBeaconClockCreateFromState(genesisState);
            Module._ETHBeaconStateDestroy(genesisState);
            trackWallTime(beaconClock);

            document.getElementById('initButton').addEventListener('click', async function() {
                const trustedBlockRootString = document.getElementById('trustedBlockRoot').value;
                if (!/^0x[0-9a-fA-F]{64}$/.test(trustedBlockRootString)) {
                    return;
                }
                document.getElementById('initButton').disabled = true;
                clearStore();

                beaconApiBase = document.getElementById('beaconApiBase').value;
                const response = await fetch(beaconApiBase +
                    '/eth/v1/beacon/light_client/bootstrap/' + trustedBlockRootString, {
                        headers: {
                            'Accept': 'application/octet-stream'
                        }
                    });
                if (response.ok) {
                    const data = await response.arrayBuffer();
                    const bootstrapBytes = new Uint8Array(data);

                    const trustedBlockRootBytes = new Uint8Array(32);
                    for (let i = 0; i < trustedBlockRootBytes.length; i++) {
                        trustedBlockRootBytes[i] = parseInt(trustedBlockRootString.substr(i * 2 + 2, 2), 16);
                    }

                    const trustedBlockRootBytesPtr = Module._malloc(trustedBlockRootBytes.length);
                    Module.HEAPU8.set(trustedBlockRootBytes, trustedBlockRootBytesPtr);
                    const mediaType = Module.stringToNewUTF8(response.headers.get('Content-Type'));
                    const consensusVersion = Module.stringToNewUTF8(response.headers.get('Eth-Consensus-Version'));
                    const bootstrapBytesPtr = Module._malloc(bootstrapBytes.length);
                    Module.HEAPU8.set(bootstrapBytes, bootstrapBytesPtr);
                    const newStore = Module._ETHLightClientStoreCreateFromBootstrap(
                        cfg, trustedBlockRootBytesPtr,
                        mediaType, consensusVersion, bootstrapBytesPtr, bootstrapBytes.length);
                    assert(newStore);
                    Module._free(bootstrapBytesPtr);
                    Module._free(consensusVersion);
                    Module._free(trustedBlockRootBytesPtr);
                    Module._free(mediaType);

                    trackStore(newStore);
                }
                document.getElementById('initButton').disabled = false;
            });
            document.getElementById('initButton').disabled = false;
        };
    </script>
    <script async src="libnimbus_lc.js"></script>
</body>
</html>
